{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"#spectral-micro-is-in-beta-stage-and-docs-and-firmware-are-under-constant-development","title":"Spectral micro is in beta stage and docs and firmware are under constant development!","text":"<p>You can buy a Spectral Micro starter kit here: Link  Or buy a single motor driver here: Link </p> <ul> <li>Spectral micro datasheet</li> <li>Getting started</li> <li>Flashing firmware</li> <li>Calibration</li> <li>PID tuning</li> <li>UART interface</li> <li>CAN interface</li> <li>Control features</li> <li>GUI interface</li> <li>Tested motors</li> <li>Theory corner</li> <li>Troubleshooting</li> </ul> <p>Guides</p> <ul> <li>Arduino guide</li> <li>CAN bus guide</li> <li>Mobile robot guide</li> <li>Python guide</li> <li>ROS2 guide</li> <li>Serial terminal guide</li> <li>Simple robot arm guide</li> <li>Quadruped robot guide</li> <li>Gravity compensation guide</li> <li>Bilateral teleoperation guide</li> <li>SimpleFOC guide</li> </ul>"},{"location":"apage1_specs/","title":"Spectral micro datasheet","text":"<p>Spectral Micro is a brushless motor controller designed to offer affordable and capable hardware, complemented by open-source software. It supports multiple firmware options and integrates a 14-bit magnetic encoder, inline current sensing, CAN and UART data interface, and provides support for position, velocity, torque, and impedance control.  Everything you need for developing high-performance robotic solutions is included.   It is ideal for gimbal motors, quadrupeds, robotic arms, and grippers. Check the list of tested motors here!</p> Features <p> </p> Electrical specs  - 3 phase brushless FOC controller   - Voltage input: 12 - 29V     - Max continuous phase current: 2.8A   - Max phase current: 2.8A (with good colling)   - Inline current sensing   - PWM switching rate: 25 kHz   - Max power: 80W    - Idle power: 0.3W   - Control loop frequency: 5kHz     - Max electrical frequency: 460 Hz  Mechanical specs    - Mass: 8 g     - Dimensions: 39mm x 39mm   - Nema 17 compatible mounting hole distances Features - STM32f103c microcontroller - 14 bit encoder   - CAN and UART communication  -  Daisy chain CAN and power connector    - EEPROM memory 16 Kbit   -  Hardware overcurrent, over-under voltage and temperature protection    - Fully open source firmware and support for SimpleFOC   - One additional pin analog input, digital input or output   - Temperature sensor connector  -  Torque, velocity, position, and Impedance control modes  -  Auto calibration features <p>Each spectral micro BLDC controller is Fully end of line tested.</p>"},{"location":"apage1_specs/#absolute-maximum-ratings","title":"Absolute maximum ratings","text":"<ul> <li>Supply voltage -&gt; min 10V, typ 24V, max 29V</li> <li>Phase current -&gt; typ 1.5A, max 2.8A</li> <li>Operating Temperature -&gt; min -20\u00b0C, typ 25\u00b0C, max 130\u00b0C</li> </ul> <p>Hardware level protection circuits and limits:</p> <ul> <li>Overcurrent protection trip level -&gt; min 3A typ 5A</li> <li>VM undervoltage lockout voltage -&gt; typ 6.3V  MAX 8v</li> <li>Thermal shutdown temperature -&gt; min 150 deg, typ 160, max 180</li> </ul>"},{"location":"apage1_specs/#connectors","title":"Connectors","text":"Connector Cable assembly Connector datasheet UART Link JST SH series Power Link JST XH series CAN Link JST ZH series JTAG Link 1.27 pitch pin header"},{"location":"apage1_specs/#pinout","title":"Pinout","text":"<p>REVERSING POLARITIY ON DC+- WILL DESTROY YOUR BOARD.</p> <p>Motor phases are conneceted to U,V and W. Power is connected to DC+ and DC-</p> <p> </p> <p> </p> <p>Note!</p> <ul> <li>to enable hal you need to solder 12 10k reistors above HAL connecor</li> <li>termistor pin is using pulldown of 54.9 kilo ohms. </li> <li>UART is 3v3 only. Using 5V will destroy the board.</li> <li>\"PIN\" can be used as analog input or general purpose input/output</li> </ul>"},{"location":"apage1_specs/#cad-and-dimensions","title":"CAD and dimensions","text":"<p>You can download Spectral micro STEP files here!</p> <p> </p> <p>Spectral micro uses same hole spacing as NEMA17 format motors.</p> <p>Magnetic encoder is located exactly at the middle of the board!</p> <p> </p>"},{"location":"apage1_specs/#can-termination","title":"CAN termination","text":"<p>To use CAN termination make sure to place the swith in ON position!</p> <p> </p>"},{"location":"apage1_specs/#pre-loaded-firmware","title":"Pre loaded firmware","text":"<p>Spectral micro comes preloaded with spectral firmware. You can check what release by using UART interface and calling the command: #Info</p> <p>Default settings that come prelaoded are:</p> <ul> <li>LED indication: 1  </li> <li>Calibrated: 0</li> <li>Using termistor: 0</li> <li>Watchdog active: 0</li> <li>Heartbeat active: 0</li> <li>UART baud rate: 256000</li> <li>CAN baud rate: 1000000</li> <li>Default CAN node ID: 0</li> <li>I AM GRIPPER: 0</li> </ul>"},{"location":"apage2_getting_started/","title":"Getting started","text":""},{"location":"apage2_getting_started/#spectral-micro-bldc-driver","title":"Spectral Micro BLDC driver","text":"<p>You can buy a Spectral Micro starter kit here: Link  Or buy a single motor driver here: Link </p>"},{"location":"apage2_getting_started/#recommended-hardware","title":"Recommended hardware","text":"<ol> <li>Diametrically magnetized magnet</li> <li>BLDC motor; check here for all tested motors</li> <li>Programming adapter</li> <li>Serial adapter</li> <li>CAN adapter </li> <li>Termistor</li> <li>CAN wires and power wires</li> </ol>"},{"location":"apage2_getting_started/#hardware-setup","title":"Hardware setup","text":""},{"location":"apage2_getting_started/#mounting-pcb-to-motor","title":"Mounting PCB to Motor","text":"<p>To mount your BLDC to PCB you can use example motor bracket and modify it for your motor.</p> <p> </p> <p>Some hardware considerations:</p> <ul> <li>Distance between motor encoder and magnet should be around 1 mm.</li> <li>Hole spacing of Spectral micro is 31 mm</li> </ul> <p> </p>"},{"location":"apage2_getting_started/#electrical-connections","title":"Electrical connections","text":"<p>REVERSING POLARITIY ON DC+- WILL DESTROY YOUR BOARD.</p> <p> </p> <ol> <li>Solder motor phases to U,W,V</li> <li>Connect motor power to one of the Power connectors terminals</li> <li>If you are using UART comms. Connect Uart adapter to UART connector</li> <li>If you are using termistor, connect it to Termistor connecor</li> <li>If you are using CAN comms. Connect CAN adapter to one of CAN connectors</li> <li>When uploading code connect JTAG adapter to JTAG connector</li> </ol> <p>Cable orientation</p> <p>ALL cables used for dasiy chain (CAN and power) need to to follow orientation as shown on the image below! Failing to follow that will destroy your motor controller! All correct cables can be bought here: https://source-robotics.com/pages/connectors-and-cables </p> <p> </p>"},{"location":"apage2_getting_started/#connecting-multiple-motors-daisy-chaining","title":"Connecting multiple motors (daisy chaining)","text":"<p>Multiple Spectral BLDC drivers and nodes can be connected to single CAN bus using daisy-chaining. First an last nodes on can bus should have termination resistors. On Spectral micro you can flip the CAN switch to \"ON\" positon to enable termination resistor.</p> <p>Power connectors can handle max 4 A DC. Usually if you are using 10ohm gimbal motor you can daisy chain 3-4 of them.</p> <p> </p>"},{"location":"apage2_getting_started/#thermistor-connection","title":"Thermistor connection","text":"<p>Solder the termistor like shown in the image. </p> <p>Thermistor is disabled by default. To enable it use command #Term 1</p> <p> </p> <p>Thermistor needs to be placed inside the motor coils. You can usually do that thru the one of the mounting holes on the bottom of the motor. You can apply thermal cement on the thermistor in the motor coils to secure it in place and improve termal conductivity.</p> <p> </p>"},{"location":"apage2_getting_started/#status","title":"Status","text":"Normal operation Calibration Error mode 3 short flashed and a pause  Flashing every 0.5 seconds  Solid LED, no flashing.  <p>If you have spectral firmware uploaded on your spectral BLDC LEDs will be in one of 3 states.</p> <ul> <li>Normal operation is when motor controller has no active errors and is calibrated</li> <li>Error mode is active if any error on the motor driver is active. List of possible errors:<ol> <li>Temperature error</li> <li>Drv error</li> <li>Encoder error</li> <li>Vbus error</li> <li>Velocity error</li> <li>Current error</li> <li>Not calibrated </li> <li>Received ESTOP</li> <li>Watchdog error</li> </ol> </li> <li>Calibration will flash when in calibration routine</li> </ul>"},{"location":"apage2_getting_started/#what-next","title":"What next?","text":"<ul> <li>Flash the latest firmware to your driver (Note that drivers arrive with preflashed firmware)</li> <li>You will need to calibrate your motor</li> <li>Tune your PID loops</li> <li>Follow one of the guides or examples to start using Spectral driver</li> </ul>"},{"location":"apage3_flashing_firmware/","title":"Flashing firmware","text":"<p>Note</p> <p>When flashing new firmware make sure you disconnect power connection and uart connection.</p> Needed hardware You can change all variables using UART and CAN so flashing firmware a lot is not necessary You will usually flash it when:  1. New version of Spectral BLDC firmware is available 2. You are doing custom code developement  3. You are using SimpleFOC firmware You will need programming adapter from here! <p> </p>"},{"location":"apage3_flashing_firmware/#connecting-to-pcb","title":"Connecting to PCB","text":"Using Adapter Step 1 Step 2 Locate JTAG PINS Press programming adapter like shown in the picture (apply small amount of pressure on the pins to get a good contact)"},{"location":"apage3_flashing_firmware/#flashing-using-visual-studio-code","title":"Flashing using visual studio code","text":"<p>Download visual studio code: Link</p> <ol> <li>Open Spectral BLDC firmware folder in VS code. (You need to have platformio installed)</li> <li>Press uplaod in VS code (Bottom left corner in VS code)</li> </ol> <p> </p>"},{"location":"apage3_flashing_firmware/#flashing-using-stm32-st-link-utility","title":"Flashing using STM32 ST-LINK Utility","text":"<p>Download STM32 ST-LINK utility Link</p> <p>HEX and binaries</p> <p>Using STM32 ST-LINK Utility you can flash only Binary or HEX files. These can be obtained from compiling source code of spectral BLDC firmware</p> <p>Open STM32 ST-LINK utility Drag and drop the binary file inside.</p> <p> </p> <p>Go to Target/settings and make sure they look like this.</p> <p> </p> <p>Go to Target/connect. In case you get a error try to install stlink drivers from here!</p> <p> </p> <p>Go to Target/program and verify. You should get pink output msg like below.</p> <p> </p>"},{"location":"apage4_calibration/","title":"Calibration","text":"<p>Spectral firmware has autocalibration feature that allows you to automatically detect and tune your motor parameters. It detects the following:</p> <ul> <li>Motor phase resistance </li> <li>Motor phase inductance</li> <li>Motor pole pair</li> <li>Motor phase order Currently has a bug and requires some manual adjustment</li> <li>Current loop PID parameters</li> </ul> <p>Vbus voltage</p> <p>When calibrating the motor use 24V supply voltage for the best results!  Using smaller voltage may result in incorrect Resistance, inductance and kt and other parameters!</p>"},{"location":"apage4_calibration/#positive-rotation","title":"Positive rotation","text":"<p>In spectral firmware positive rotation is always counter-clockwise. That means that positive current will result in rotation in that direction. Positive speed setpoint will rotate motor in that direction and rotating in that direction will increase motor positon!</p> <p> </p>"},{"location":"apage4_calibration/#default-calibration-settings","title":"Default calibration settings","text":"<p>Calibration default setting are:</p> <ul> <li>Current loop bandwidth: 100.00Hz -&gt; Used to calculate current loop PI parameters, setting this too high will result in vibrating motor and audiable noise</li> <li>Resistance voltage: 1000mV  -&gt; We start to measure resistance at this voltage and increase it until power dissipation reaches the \"Max Power dissipation\" parameter below</li> <li>Max Power dissipation: 12.00W -&gt; Used for resistance measure and as a maximum that we can dissipate when calculating inductance</li> <li>Open loop voltage: 5000mV -&gt; What voltage we will use for open loop control (used to calculate Pole pairs)       </li> <li>Open loop Speed: 20.00Rad/s -&gt; Electrical speed we will use for open loop (used to calculate Pole pairs)     </li> <li>Phase search voltage: 500 -&gt; Used when spinning the motor to find correct phase order</li> </ul> <p>These generic parameters will work for motor with resistances ranging from 2 - 24 ohms.</p> <p>Danger</p> <p>Using these settings on motors with lower resistance (for example Drone BLDC motors) can be destructive for Spectral BLDC driver.</p> <p>Note</p> <p>Resistance and inductance values returned from calibration will have variations and are just estimates of real values.</p> <p>Note that the values that Spectral drives calculate are only estimations and if you want to get exact values use high precision insturments to measure them.</p>"},{"location":"apage4_calibration/#calling-calibration-routine","title":"Calling calibration routine","text":"<p>Calibration routine can only be called from the UART interface. The command is:</p> <pre><code>#Cal\n</code></pre>"},{"location":"apage4_calibration/#calibration-routine-output","title":"Calibration routine output","text":"<p>Note</p> <p>Values that our calibration routine returns here are specific to motor we tested. Your numbers WILL be different!</p> <p>Tip</p> <p>In case your motor stays in one step of the calibration routine too long issues a #reset command and try again. Also do that in case you dont get full log messages from the routine.</p> <p>After calling calibration routine the following will happen:</p> <p>Window with default calibration settings These are the setting that will be used for calibration</p> <pre><code>Calibration mode\n-----Settings-----\nCurrent loop bandwidth: 100.00Hz \nResistance voltage: 1000mV       \nMax Power dissipation: 12.00W    \nOpen loop voltage: 5000mV        \nOpen loop Speed: 20.00Rad/s      \nPhase search voltage: 500\n</code></pre> <p>Magnet and Vbus check Motor will check Vbus voltage and try to  detect Encoder magnet. If both passed you will get:</p> <pre><code>Magnet test: Passed\nVbus test: Passed\n</code></pre> <p>Even if the magnet test \"passed\" your magnet could still be too far or to close (touching) the encoder IC. You need to make sure that distance between the magnet and the IC is 1mm.</p> <p>Resistance and inductance measurement In the this step motor will start to produce clicking sounds, by doing that it will measure resistance and inductance. The output will be as follows:</p> <pre><code>Resistance = 7.026575Ohm\nInductance = 0.001492H\nKp_iq = 1.288308\nKi_iq = 0.630704\n</code></pre> <p>Motor will also calculate Kp_iq and Ki_iq using measured resistance, inductance and given current loop bandwidth.</p> <p>Pole pair check Motor will spin in one direction to check the number of pole pairs. Output will look like this:</p> <pre><code>Pole pair = 11\n</code></pre> <p>Phase wire disconnected</p> <p>Motor is wobbling left and right during calibration? One of your motor wire phases is disconnected!</p> <p>Motor is wobbling left and right during calibration? One of your phases is disconnected</p> <p>Phase order dir Motor will start to spin in both directions. Good output will look like this:</p> <pre><code>Phase order = 2\nPhase order is good!\n</code></pre> <p>In case you get:</p> <pre><code>Phase order = 0 \nPhase order is wrong!\nSwitch motor phases and try again!\nCalibration failed!\n</code></pre> <p>Power off the motor and switch any 2 motor phases. Re run the calibration. If you get the same error again switch motor phases again until you get:</p> <pre><code>Phase order is good!\n</code></pre> <p>Kt, KV and flux linkage dir Motor will start to spin fast in one direction for a short time. Good output will look like this (Your numbers will be different):</p> <pre><code>KV is: 39.41667 \nKt is: 0.20981\nFlux linkage is: 0.012716\n</code></pre> <p>Errors</p> <p>Note that in this step we measure motor KV and from that Kt and flux linkage. KV measurement can be wrong due the a lot of factors  and for cheap and poor quality motors you can get different results in by 2-3 times magnitude. </p> <p>Calibration end In case your calibration was succesful you will get message like below. Make sure to save the config. After the successful config is saved you dont need to re run calibration when you start your motor driver.</p> <pre><code>Calibration success!\nSave config with #Save\nGoing to idle!\n</code></pre> <p>Note</p> <p>You will need to re run the calibration if you change your motors or change motor phases.</p> <p>False success!</p> <p>There is a known issue related to the encoder magnet's attachment to the motor rotor. If the magnet is not securely fastened and can slip or rotate freely, the motor may incorrectly report that the calibration process was successful when, in fact, it was not. To avoid this problem, it's crucial to ensure that the magnet is firmly secured to the motor rotor. Proper attachment of the magnet ensures the accuracy of the calibration process and prevents potential errors in motor operation.</p>"},{"location":"apage4_calibration/#troubleshooting","title":"Troubleshooting","text":"<p>No magnet detected</p> <pre><code>Magnet test: Failed\n</code></pre> <p>Vbus to low or not detected</p> <pre><code>Vbus test: Failed\n</code></pre> <p>Motor is not connected or damaged</p> <pre><code>Resistance test: Failed\n</code></pre> <p>Wrong phase order. Switch motor phases</p> <pre><code>Phase order is wrong!\nSwitch motor phases and try again!\nCalibration failed!\n</code></pre> <p>If calibration is successful but your LED is in error mode and calling #Error reports no error try to call #Info command. If you see -1 somwhere that means that default config was no loaded and eeprom is filled with junk variables. To fix that call the #Default command.</p>"},{"location":"apage5_PID_tuning/","title":"PID tuning","text":"<p>Tuning the motor controller is crucial for maximizing the performance of any motor controller. Proper tuning ensures that the controller can swiftly respond to disturbances  like external forces or changes in the setpoint, without going unstable.</p> <p>The process of tuning PID gains typically involves iterative adjustments, demanding a systematic approach to attain the desired performance level. Here's a fundamental guide for tuning the PID gains tailored for your Spectral controller:</p> <ul> <li>Ensure that the motor's behavior won't lead to damage or injury in case of unexpected oscillations or erratic movements. </li> <li>Secure the stator assembly firmly to prevent loosening in the event of oscillations.</li> <li>Conduct PID tuning without any gearbox or additional objects attached to the motor's rotor. This approach helps isolate the motor's response for more accurate tuning.</li> <li>If the default PID gains induce oscillations, reduce all gains until the system stabilizes. Incrementally adjust the gains, making small changes at a time.</li> </ul> <p>To tune PID loops you can use UART protocol or CAN protocol. We recommend UART and here we will showcase example commands for UART protocol. To tune the controller you will need to have it fully calibrated and without any active errors. Otherwise it will not allow you to enter any of the needed modes like: position, speed or current mode.</p>"},{"location":"apage5_PID_tuning/#tuning-cascade-postion-velocty-and-current-controller","title":"Tuning cascade postion, velocty and current controller","text":"<p>For tuning the cascaded structure, we should first focus on the inner loops and move outward.</p>"},{"location":"apage5_PID_tuning/#tuning-the-current-controller","title":"Tuning the Current controller","text":"<p>The innermost stage is always a current/torque controller that accepts torque/current requests and uses a PI controller to select voltage (PWM values) to achieve that current. You need to pick Kp and Ki for that loop. If they are too large, they can create audible noise or instability. If they are too small, the response to changes in commanded torque or disturbances will be reduced.</p> <p>Torque bandwidth (current loop bandwitdh) is mesure of how fast a system can respond to those commands or disturbances.  Current controller can be auto tuned during the calibration by selecting desired torque/current bandwidth (UART command #Cbw).  Motor calibration measures your motor\u2019s  phase resistance and phase inductance. It uses this information and desired torque bandwidth setpoint to set its current controller gains. Default torque bandwitdh is 200 Hz. </p> <p>** Generally in industry bandwidths of more than 800 Hz are standard. ** Higher torque bandwidth is desired for legged robots, or other applications where it is necessary to respond to external disturbances as fast as possible. Higher torque bandwidths will result in audiable noise and if they are too large in drive instability.</p> <p>We recommned tuning the current controller gains with auto tune feature in #Cal command.</p> <p>If you want to tune it by hand:</p> <ol> <li>Increase proportional gain until system starts to become unstable (it will oscilate or create humming sounds). Use command #Kpiq</li> <li>Reduce that value by 20% and comfirm that there is no oscilation. If it still oscilates reduce it more.</li> <li>Now slowly increase Ki until system starts to become unstable (it will oscilate or create humming sounds). Use command #Kiiq</li> <li>Reduce the value slightly until it becomes stable.</li> </ol> <p>To test the current controller you will need to issue a #Iq VALUE Command. VALUE will be the value of Iq current you want as a setpoint, make sure it is not too large and that your motor can handle it.</p>"},{"location":"apage5_PID_tuning/#tuning-the-velocity-controller","title":"Tuning the velocity controller","text":"<p>So after making sure the Torque loop works in an acceptable manner, we can start tuning velocity controller. </p> <ol> <li>Controllers come preloaded with weak gains. If it oscilates with them reduce Kp and Ki to 0.</li> <li>Increase proportional velocity gain until system starts to become unstable (it will oscilate or create humming sounds). Use command #Kpv</li> <li>Reduce that value by 20% and comfirm that there is no oscilation. If it still oscilates reduce it more.</li> <li>Now slowly increase Ki until system starts to become unstable (it will oscilate or create humming sounds). Use command #Kpi</li> </ol> <p>Tip</p> <p>Bear in mind that the Ki gain is highly sensitive as it acts as an integrator accumulating over time. Setting excessively high values for Ki can potentially render your system unstable. For some motors, setting the Speed controller Ki to zero and relying solely on the Speed controller Kp gain might be adequate. However, in such cases, getting a zero steady-state error is hard. Therefore, the Ki gain plays a important role in both reaching the desired goal and sustaining it over time.</p> <ol> <li>Reduce the value of Ki slightly until it becomes stable.</li> <li>If you think you tuned your controller start to experiment with different speeds and see how it reacts and tracks them.</li> </ol> <p>Give the motor #V VALUE command. VALUE will be the value of velocity in encoder ticks/s we want to achieve, make sure it is not to large or too small and that your motor can handle it.</p>"},{"location":"apage5_PID_tuning/#tuning-the-position-controller","title":"Tuning the position controller","text":"<ol> <li>Controllers come preloaded with weak proportional gain. If it oscilates with it reduce it to 0.</li> <li>Start increasing the proportional gain. The system will use the already-tuned current and velocity controller as inner loops. Use command #Kpp</li> <li>Increase until you notice overshoot in the position response. If overshooting is excessive or oscillations start, reduce the gain slightly until satisfactory performance is achieved without instability.</li> <li>Ideally, the response should be quick to reach the desired position but without excessive oscillations.</li> </ol> <p>You can set motor positon command by using #P VALUE. VALUE will be the value of position in encoder ticks.</p>"},{"location":"apage5_PID_tuning/#testing-the-cascade-controller","title":"Testing the cascade controller","text":"<p>If you think you system is tuned:</p> <ol> <li>Conduct tests across the entire spectrum of operational conditions to verify stability and performance under various scenarios.</li> <li>If possible, introduce disturbances such as changes in load to assess the system's robustness and response to external factors.</li> <li>Based on real-world performance observations, adjust the gains as necessary to optimize the system's behavior and ensure consistent performance across different conditions.</li> <li>If you think you tuned your controller start to experiment with different speeds and see how it reacts and tracks them.</li> </ol>"},{"location":"apage5_PID_tuning/#tuning-impedance-pd-controller","title":"Tuning impedance PD controller","text":"<p>TODO</p>"},{"location":"apage5_PID_tuning/#velocity-limits","title":"Velocity limits","text":"<p>To get an estimate of how fast your motor can spin use this formula: Max_velocity [encoder ticks /s] = ((0.8 * Vbus * KV) * 16384) / 60 </p>"},{"location":"apage5_PID_tuning/#current-limits","title":"Current limits","text":"<p>Changes from motor to motor.  Note that MOSFET stage has automatic shutdown if we go over some current or temperature goes to high. But we are also monitoring with software, controller will go to error mode if any phase current is bigger than 3.4 A. Motor temperature is important here. To not to destroy your motor; carefully select your current limits based on rated power of the motor your testing.</p> <p>You hear crunching and whining sounds. Your current limit might be too high, lower it.</p>"},{"location":"apage5_PID_tuning/#integral-accumulator-reset-todo-test","title":"Integral accumulator reset - TODO test","text":"<p>Here's why resetting the integral accumulator might be advantageous:</p> <ul> <li> <p>Segmented Velocity Profile: If your velocity profile consists of distinct segments with different velocities, resetting the integral accumulator when transitioning between segments can help prevent integral windup. This ensures that the integral term doesn't accumulate excessive error during the transition, which could lead to overshoot or instability.</p> </li> <li> <p>Reducing Error Accumulation: Resetting the integral term allows the controller to start accumulating error from the new setpoint, which can help maintain accuracy and responsiveness, particularly if there are sudden changes or disturbances in the system.</p> </li> <li> <p>Improved Response: By resetting the integral term, you ensure that the controller responds promptly to changes in the velocity profile without being influenced by past errors that may no longer be relevant.</p> </li> </ul> <p>However, it's essential to consider the dynamics of your system and the characteristics of the velocity profile. If the transitions between velocity segments are smooth and gradual, or if the feedforward component adequately compensates for changes in velocity, resetting the integral term may not be necessary.</p> <p>Ultimately, it may require some experimentation and tuning to determine the optimal behavior for your specific application, taking into account factors such as stability, response time, and accuracy.</p>"},{"location":"apage6_uart/","title":"UART interface","text":"<p>The UART interface is more interactive and user-friendly compared to CAN. With just a serial monitor and a USB-to-serial device, you can communicate with your motor and receive interactive, human-readable responses.</p> <p>Disadvantages: </p> <ul> <li>Passing human-readable data is slow and limiting if you aim for high-performance control.</li> <li>Only one device per UART channel, so no daisy chaining.</li> <li>Susceptible to noise.</li> </ul> <p>Default baud rate is: 256000 (Max tested baudrate is 1000 0000)</p>"},{"location":"apage6_uart/#how-to-connect","title":"How to connect","text":"<ul> <li>TODO how to connect to serial adapter</li> </ul> <p>Voltage warrning</p> <p>Spectral micro UART port uses 3.3 volts. Using 5V will destroy your board!</p> <p> </p> <p>UART pins</p> <p>Take note that UART is connected TX to RX and RX to TX</p>"},{"location":"apage6_uart/#using-serial-monitor","title":"Using serial monitor","text":"PuttyVScodeArduino <p>Download Putty from this link: Modified Putty</p> <p>Note</p> <p>You need to have Putty from above link to add CR LF option. Stock Putty cant do that!</p> Step 1 Step 2 Go to keyboard tab and Select CR LF option Enter serial port of your adapter and enter speed; Click Open <p> </p> <p> </p> <p>Download VScode from this link: VS code Open Spectral firmware in VS code (You will need to install Platformio extension)</p> Step 1 Step 2 Made sure your platformio.ini file looks like this (usually platformio will auto detect the COM port) Click the icon marked in red and that will open a serial terminal <p> </p> <p> </p> <p> </p> <p>Download Arduino from this link: Arduino</p> <p>Select matching COM port of your serial adapter <p> </p> For boards we usually select \"Adafruit Circuit Playground\" <p> </p> In tools tab press Serial monitor <p> </p></p>"},{"location":"apage6_uart/#uart-protocol","title":"UART protocol","text":"<p>All commands need to start with # and end with CR + LF (carriage return \\r + Newline (Line Feed) \\n).</p> <p>CR + LF</p> <p>Usually CR + LF is inserted by the terminal you use when you press enter.</p> <p>All commands are response-only; that means the motor driver will never send data over UART unless it receives a request from the host.</p> <p>Cyclic commands</p> <p>Only exceptions are cyclic commands that allow you to set up motor driver to periodically send some data.</p> <p>Aftter # You can enter your command. For example: #Error  Commands that are type <code>set/get</code> can have a number argument after command name. Number argument for command can be one of following types as described in table column \"Input Data type\"</p> <ul> <li>int - positive and negative integer values</li> <li>float - positive and negative float values</li> <li>bool - 0 or 1</li> </ul> <p>Commands and numbers need to be seperated by a single space! Example: #LED 1</p> <p>Commands are case sensitive!</p> <p>Command names are case sensitive and need to be same as in the table to be registred.</p> <p>Template of command: <code>#Name number</code></p> <p>Here are few examples:</p> <ul> <li>Calling <code>#P 100</code> will set our motor to positon mode with setpoint of 100 and return its current position, but calling <code>#P</code> will only return current positon of the motor.</li> <li>Calling <code>#V 1000</code> will set motor to velocity mode with setpoint of 100 and return its current velocity, but calling <code>#V</code> will only return current velocity of the motor.</li> <li>Calling <code>#LED 1</code> will enable led indication on the motor and <code>#LED 0</code> will disable it; also both examples wilL return its current status. Calling only <code>#LED</code> will tell us the current status.</li> </ul> <p>As you can see Responses of Set/Get  commands do not change if they have number command after command name. So calling <code>#P</code> and <code>#P 100</code> will have same response; defined in Response tab of the table.</p> <p>Action commands</p> <p>Commands of type <code>action</code> do not take any second arguments. </p> <p>Cyclic  commands: There are few cyclic commands available. they initiate a motor to send data every timeinterval we set.</p> <ol> <li><code>Cyc</code></li> <li><code>Cyca</code></li> </ol>"},{"location":"apage6_uart/#list-of-commands","title":"List of commands","text":""},{"location":"apage6_uart/#motion-commands","title":"Motion commands","text":"Name Type Input Data type Desciption Response <code>Iq</code> Set/Get float <code>Switches actuator to current control mode and sets current setpoint to Iq value.</code> Iq value [mA] <code>V</code> Set/Get int <code>Switches actuator to velocity control mode and sets velocity to setpoint V</code> Velocity value [Encoder ticks/s] <code>P</code> Set/Get int <code>Switches actuator to position mode and sets positon setopint to P value</code> Position [Encoder ticks] <code>PD</code> Set/Get int <code>Switches actuator to Impedance PD control mode and sets position setpoint to PD value</code> Current position [Encoder ticks] <code>PDV</code> Set/Get int <code>Set/Get velocity setpoint when in Impedance PD mode.</code> Current velocity setpoint when in PD mode <code>PDI</code> Set/Get int <code>Set/Get current setpoint when in Impedance PD mode</code> Current current setpoint when in PD mode <code>Openloop</code> Set/Get int <code>Enter open loop mode and spin with speed; Example #Openloop 1000; Motor will use voltage preset given by #Openv command</code> Value of open-loop speed"},{"location":"apage6_uart/#pid-tuning-commands","title":"PID tuning commands","text":"Name Type Input Data type Desciption Response <code>Kpp</code> Set/Get float <code>Set/Get position loop Kp gain</code> Current value of Kpp <code>Kpv</code> Set/Get float <code>Set/Get velocity loop Kp gain</code> Current value of Kpv <code>Kiv</code> Set/Get float <code>Set/Get velocity loop Ki gain</code> Current value of Kiv <code>Kpiq</code> Set/Get float <code>Set/Get current loop Kp gain (Iq and Id loop)</code> Current value of Kpiq <code>Kiiq</code> Set/Get float <code>Set/Get current loop Ki gain (Iq and Id loop)</code> Current value of Kiiq <code>Kpid</code> Set/Get float <code>Set/Get Id current loop Kp gain.</code> Current value of Kpid <code>Kiid</code> Set/Get float <code>Set/Get Id current loop Ki gain.</code> Current value of Kiid <code>Vlimit</code> Set/Get int <code>Clamp velocity integrator to the value of Vlimit</code> Current value of Vlimit [Encoder ticks/s] <code>Ilim</code> Set/Get int <code>Set/Get Iq current limit</code> Current value of Ilim [mA] <code>Id</code> Set/Get float <code>Set/Get the value of Id setpoint. Usually we do not touch this and should stay at 0</code> Id value [mA] <code>KP</code> Set/Get float <code>Set/Get KP of impedance PD loop</code> Current value of KP <code>KD</code> Set/Get float <code>Set/Get KD of impedance PD loop</code> Current value of KD <code>Rstint</code> Set/Get bool <code>Set/Get do we want to reset integral accumulators after receiving new setopint, default is 0.</code> 0 if disabled 1 if enabled"},{"location":"apage6_uart/#calibration-and-motor-parameter-commands","title":"Calibration and motor parameter commands","text":"Name Type Input Data type Desciption Response <code>Cal</code> Action <code>Start motor calibration procedure</code> <code>R</code> Set/Get float <code>Set/Get phase Resistance</code> Phase Resistance [Ohm] <code>L</code> Set/Get float <code>Set/Get phase Inductance</code> Phase Inductance [Ohm] <code>PP</code> Set/Get int <code>Set/get Number of POLE PAIRS!</code> Current nomber of pole pairs <code>Kt</code> Set/Get float <code>Set/Get Kt (Torque constant)</code> Current value of Kt <code>KV</code> Set/Get float <code>Set/Get KV (motor velocity constant)</code> Current value of KV <code>Flux</code> Set/Get float <code>Set/Get flux linkage</code> Current flux linkage value <code>Magnet</code> Action <code>Gets magnet status</code> Good or Bad <code>Dir</code> Set/Get bool <code>Set/Get Dir</code> Current value of Dir <code>Phase</code> Set/Get int <code>Set/Get Phase order</code> Current value of Phase order <code>Cbw</code> Set/Get int <code>Set/Get current loop bandwidth [Hz]</code> Current current loop bandwidth <code>Resv</code> Set/Get int <code>Set/Get voltage used when looking for resistance value (Used in #Cal function)</code> Current voltage used when looking for resistance <code>Calpwr</code> Set/Get int <code>Set/Get max power that can be used during Inductance and resistance search (Used in #Cal function)</code> Current calibration power <code>Openv</code> Set/Get int <code>Set/Get voltage used during open loop operation (Used in #Cal function and when using #Openloop)</code> Current open loop voltage <code>Opens</code> Set/Get int <code>Set/Get open loop calibration speed (Used in #Cal function)</code> Current open loop calibration speed <code>Vp</code> Set/Get int <code>Set/Get phase order search voltage (Used in #Cal function)</code>"},{"location":"apage6_uart/#utility-commands","title":"Utility commands","text":"Name Type Input Data type Desciption Response <code>Idle</code> Action <code>Set motor to idle state</code> <code>Save</code> Action <code>Save current config to EEPROM</code> <code>LED</code> Set/Get bool <code>Enable disable LED status</code> Current status of LED indication; 0 is off, 1 is on <code>Reset</code> Action <code>Reset the MCU</code> <code>Default</code> Action <code>Load default config to EEPROM</code> **Note this will rewrite all data saved in eeprom (including serial number, hardware version, batch date...) Before using it make sure to manually backup any important data. <code>Temp</code> Action <code>Get termistor temperature in degrees</code> Temperature in degrees <code>Term</code> Set/Get bool <code>Enable/disable termistor mesurment</code> 0 disabled 1 enabled <code>Tlim</code> Set/Get int <code>Set/Get the temperature at which thermal error will trigger</code> Be careful here value of 75 is default and it is not recommended to go higher than that unless you know you motor is rated for more <code>Mode</code> Action <code>Get current operating mode</code> Operating mode (Open loop, Idle, Positon control...) <code>Vbus</code> Action <code>Get current value of Vbus</code> current value of Vbus [mV] <code>Error</code> Action <code>Get current state of all errors</code> List of errors <code>Clear</code> Action <code>Clear all errors and go to idle; *NOTE: this will not clear calibration error if drive is not calibrated.</code> <code>Iabs</code> Action <code>Get value of motor phase currents</code> value of phase currents [mA] <code>Close</code> Action <code>Enter closed loop mode</code> <code>PWM</code> Action <code>Get value of PWM values</code> Current PWM values <code>Info</code> Action <code>Get Information about motor driver and motor</code> Motor information <code>Param</code> Action <code>Get all currently set PID parameters for every control mode</code> PID parameters <code>Cyc</code> Set/Get int <code>Periodically send messages</code> <code>Cyca</code> Set/Get int <code>Periodically send messages arduino format</code> <code>CANID</code> Set/Get int <code>Set/Get CAN ID (can be from 0 - 15)</code> Current CAN node ID <code>SERNUM</code> Set/Get int <code>Set/Get motor controller serial number</code> Current serial number of motor controller <code>Calibrated</code> Set/Get bool <code>Set/Get motor calibration status. *NOTE: calling #Calibrated 1 will set controllers calibration status to 1 but motor controller might not be properly calibrated. To run auto calibration run #Cal command</code> Calibrated or not calibrated <code>Activate</code> Set/Get bool <code>Activate the motor (Not used in this version of code)</code> <code>Pullconfig</code> Action <code>Prints all motor data over serial; used for updating the Spectral motor GUI</code> Motor data seperated by single space char"},{"location":"apage6_uart/#gripper-commands","title":"Gripper commands","text":"<p>Commands used when in gripper mode. Procedure: </p> <ul> <li>Gripper 1 (Tells our motor controller we are using it as gripper)</li> <li>Gripcal (this will calibrate the gripper)</li> <li>Gripvel x (x is value from 0 - 255; 0 being min speed 255 max speed)</li> <li>Gripcur x (x is value from 0 - 1000 [mA])</li> <li>Grippos x (x is vale from 0 - 255; 0 being fully open 255 fully closed)</li> </ul> Name Type Input Data type Desciption Response <code>Gripper</code> Set/Get bool <code>Set/get Am I a gripper</code> Is this device gripper or not <code>Gripcal</code> Action <code>Start gripper calibration</code> None <code>Grippos</code> Set/Get uint8_t <code>Set/get desired gripper setpoint position (from 0 to 255). Also will set gripper into GOTO mode and execute the command</code> Gripper positon value <code>Gripvel</code> Set/Get uint8_t <code>Set/get desired gripper velocity setpoint (from 0 to 255)</code> Gripper velocity value setpoint <code>Gripcur</code> Set/Get int <code>Set/get desired gripper current in mA from 0 - 1000 (Note value below 150 are unstable)</code> Gripper current value setpoint; to get current current value use #Iq <code>Gripact</code> Set/Get bool <code>Set/get gripper activation bit</code> Is gripper activated or not <code>Gripstop</code> Set/Get bool <code>Set/get gripper Estop bit</code> Gripper estop bit status <code>Gripinfo</code> Action <code>Print information about this gripper</code> All information about gripper like: is it calibrated, status, endstop values..."},{"location":"apage6_uart/#cyclic-commands","title":"Cyclic commands","text":"<p>TODO</p>"},{"location":"apage7_can/","title":"CAN interface","text":"<p>CAN bus should be your primary choice when developing robotic aplication.  Spectral micro uses 5V CAN bus that adheres to the CAN 2.0 standard. Each Spectral micro has 2 CAN bus connectors allowing you to easily daisy chain multiple devices. </p> <p> </p> <p>Bits 10 - 7 of CAN ID represent Node ID.  Node IDs can range from 0 - 15 Meaning you can have maximum 16 different devices on one CAN bus.</p> <p>Bits 6 - 1 of the CAN ID represent Command ID. Command IDs can range from 0 - 63.</p> <p>Bit 0 represents error bit. If spectral micro BLDC controller has any active error this bit will be set to 1. Note this bit is send always by the driver and is independent about the command ID and data.</p> <p>Node with smallest Node ID is strongest in CAN bus arbitration.</p> <p>If you want to learn more about CAN bus we recommend you read this article!</p> <p>This page describes can protocol; Go to CAN bus guide for hardware setup and examples You can use our Python CAN bus API to communicate with your Spectral BLDC controllers! If you want to se more examples on how to write Python scripts to control your motor over CAN check this guide!</p>"},{"location":"apage7_can/#list-of-commands","title":"List of commands","text":"<p>Messages prefixed with Send are messages that the host can send to the Spectral BLDC controller. Note that to some of these messages the driver will respond with pre-defined message prefixed with Respond</p> <p>Messages prefixed with Respond  are messages that the Spectral BLDC controller can send to the host.</p> <p>Messages prefixed with Send_Respond are messages that host can request from BLDC controller and it will respond with the desired data packet with the same Command ID as recived command. Host is sending these msgs with RTR bit and Spectral is responding with RTR 0 and some data packet.</p> Command ID Name Type Data 9 <code>Respond_Heartbeat</code> Respond None 3 <code>Respond_data_pack_1</code> Respond Position [Encoder ticks]  Velocity [Encoder ticks/s]  Current [mA] 5 <code>Respond_data_pack_2</code> Respond Data 7 <code>Respond_data_pack_3</code> Respond Data 60 <code>Respond_Gripper_data_pack</code> Respond Position   Current  Gripper activation status  Gripper action status  Object detection status   Temperature error  Timeour error  Estop error  Calibration status Command ID Name Type Data 2 <code>Send_data_pack_1</code> Send Position [Encoder ticks]  Velocity [Encoder ticks/s]  Current [mA] 6 <code>Send_data_pack_2</code> Send Data 8 <code>Send_data_pack_3</code> Send Data 4 <code>Send_data_pack_PD</code> Send Position [Encoder ticks]  Velocity [Encoder ticks/s]  Current [mA] 61 <code>Send_gripper_data_pack</code> Send Position   Velocity   Current [mA]   Gripper activation   Gripper action  Estop status  Release direction 62 <code>Send_gripper_calibrate</code> Send None 16 <code>Send_PD_Gains</code> Send KP  KD 17 <code>Send_Current_Gains</code> Send Kpiq  Kiiq 18 <code>Send_Velocity_Gains</code> Send Kpv  Kiv 19 <code>Send_Position_Gains</code> Send Kpp 20 <code>Send_Limits</code> Send Velocity limit  Current limit 22 <code>Send_Kt</code> Send Kt 11 <code>Send_CAN_ID</code> Send CAN ID 0 <code>Send_ESTOP</code> Send None 12 <code>Send_Idle</code> Send None 13 <code>Send_Save_config</code> Send None 14 <code>Send_Reset</code> Send None 1 <code>Send_Clear_Error</code> Send None 15 <code>Send_Watchdog</code> Send Time  Action 30 <code>Send_Heartbeat_Setup</code> Send Time 29 <code>Send_Cyclic_command</code> Send Data Command ID Name Type Respond data 23 <code>Send_Respond_Temperature</code> Send/Respond Temperature 24 <code>Send_Respond_Voltage</code> Send/Respond Vbus voltage 25 <code>Send_Respond_Device_Info</code> Send/Respond Serial number  Hardware version  Batch date  software version 26 <code>Send_Respond_State_of_Errors</code> Send/Respond Error  Temperature error  Encoder error  Vbus error  Driver error  Velocity error  Current error  ESTOP error  Calibration status  Activated status  Watchdog error 27 <code>Send_Respond_Iq_data</code> Send/Respond Iq current 28 <code>Send_Respond_Encoder_data</code> Send/Respond Position [Encoder ticks]  Velocity [Encoder ticks/s] 10 <code>Send_Respond_Ping</code> Send/Respond None"},{"location":"apage7_can/#watchdog","title":"Watchdog","text":"<p>By default watchdog is turned off. Each valid CAN message received by the spectral BLDC resets its watchdog timer. Watchdog measures time between the commands that spectral BLDC receives. If it is bigger than time you set it will report Watchdog error and go to error mode. To clear the error you will need to call:</p> <pre><code>\"Send_Clear_Error\"\n</code></pre>"},{"location":"apage7_can/#heartbeat","title":"Heartbeat","text":"<p>By default heartbeat will send data at 1Hz or every 1 second. Hearbeat is function that will Send \"Respond_Heartbeat\" msg every time interval you set in \"Send_Heartbeat_Setup\".  This is usefull when your host device needs to see if spectral BLDC is connected/alive.  In case your spectral BLDC sends any other data (as a response to command) it will reset its heartbeat timer.</p> <p>Heartbeat timer reset</p> <p>For example if spectral BLDC is sending data every 10ms and heartbeat is setup to send every 1s; hearbeat will never send its data. </p>"},{"location":"apage7_can/#cyclic","title":"Cyclic","text":"<p>TODO</p>"},{"location":"apage7_can/#commands","title":"Commands","text":""},{"location":"apage7_can/#respond_heartbeat","title":"Respond_Heartbeat","text":"<p>This is the command that driver will send as its heartbeat every X ms. It is an empty data frame.</p> <ul> <li>Command ID: 9 </li> <li>Direction: BLDC driver -&gt; host </li> <li>Python call: None, this command is sent only by driver </li> <li>Length: 0 byte</li> <li>Type of frame: standard</li> </ul>"},{"location":"apage7_can/#respond_data_pack_1","title":"Respond_data_pack_1","text":"<p>This is the command that driver will send as a response to movement commands like Send_data_pack_1 and Send_data_pack_PD. </p> <ul> <li>Command ID: 3 </li> <li>Direction: BLDC driver -&gt; host </li> <li>Python call: None, this command is sent only by driver </li> <li>Length: 8 byte</li> <li>Type of frame: standard </li> </ul> Size (bytes) Variable (Spectral_BLDC Lib python attribute) Type Details 0 - 2 position signed 24bit unit is encoder ticks 3 - 5 velocity signed 24bit unit is encoder ticks /s 6 - 7 current signed 16bit unit is mA"},{"location":"apage7_can/#respond_gripper_data_pack","title":"Respond_Gripper_data_pack","text":"<p>This is the command that driver will send as a response to Send_gripper_data_pack. </p> <ul> <li>Command ID: 60 </li> <li>Direction: BLDC driver -&gt; host </li> <li>Python call: None, this command is sent only by driver </li> <li>Length: 4 byte </li> <li>Type of frame: standard </li> </ul> Size (bytes) Variable (Spectral_BLDC Lib python attribute) Type Details 0 gripper_position unsigned 8bit 255 fully closed, 0 fully open 1-2 gripper_current 16 bit signed 0 min current, 1300 max current, unit mA 3(bit 0) gripper_activated bit (0/1) gripper activate (1) / deactivated (0) 3(bit 1) gripper_action_status bit (0/1) 1 is goto, 0 is idle or performing auto release or in calibration 3(bit 2 and 3) gripper_object_detection 2 bit 0 in motion, 1 object detected closing, 2 object detected opening, 3 at positon 3(bit 4) gripper_temperature_error bit (0/1) gripper_temperature_error 3(bit 5) gripper_timeout_error bit (0/1) gripper_timeout_error 3(bit 6) gripper_estop_error bit (0/1) gripper_estop_error 3(bit 7) gripper_calibrated bit (0/1) gripper calibration status; calibrated (1) / not calibrated (0)"},{"location":"apage7_can/#send_data_pack_1","title":"Send_data_pack_1","text":"<p>This command will place the driver in position, speed or current control mode depending on the amount of paramters you give it. Note that if you dont want feedforward just set it to 0. </p> <ul> <li>Command ID: 2 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python call: Send_data_pack_1() </li> <li>Type of frame: standard </li> <li>Lenght: 8 byte -  If using positon setpoint with speed and current feedforward</li> </ul> Size (bytes) Variable Type Details 0 - 2 Position setpoint signed 24bit unit is encoder ticks 3 - 5 Velocity feedforward signed 24bit unit is encoder ticks/s 6 - 7 Current feedforward signed 16bit unit is mA <ul> <li>Lenght: 5 byte -  If using speed setpoint and current feedforward</li> </ul> Size (bytes) Variable Type Details 0 - 2 Velocity setpoint signed 24bit unit is encoder ticks/s 3 - 5 Current feedforward signed 16bit unit is mA <ul> <li>Lenght: 2 byte -  If using current setpoint</li> </ul> Size (bytes) Variable Type Details 0 - 1 Current setpoint signed 16bit unit is mA <p>Driver will respons to this command with: Respond_data_pack_1</p>"},{"location":"apage7_can/#send_data_pack_pd","title":"Send_data_pack_PD","text":"<p>This command will place the driver in impedance PD control mode. </p> <ul> <li>Command ID: 4 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python call: Send_data_pack_PD() </li> <li>Type of frame: standard </li> <li>Length: 8 byte </li> </ul> Size (bytes) Variable Type Details 0 - 2 Position signed 24bit unit is encoder ticks 3 - 5 Velocity signed 24bit unit is encoder ticks/s 6 - 7 Current signed 16bit unit is mA <p>Driver will respond to this command with: Respond_data_pack_1</p>"},{"location":"apage7_can/#send_gripper_data_pack","title":"Send_gripper_data_pack","text":"<p>This command will command the motor (SSG48 gripper) to move to specific position with speed/torque.</p> <ul> <li>Command ID: 61 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_gripper_data_pack() </li> <li>Type of frame: standard </li> <li>Length: 5 byte </li> </ul> Size (bytes) Variable Type Details 0 Position unsigned 8bit 0 fully open, 255 fully closed 1 Velocity unsigned 8bit 0 min speed, 255 max speed 2-3 Current signed 16bit 0 min current, 1300 max current, unit mA 4(bit 0) Gripper activate bit (0/1) 0 deactivate the gripper, 1 activate the gripper 4(bit 1) Gripper action status bit (0/1) 4(bit 2) Gripper estop status bit (0/1) 4(bit 3) Gripper release direction bit (0/1) <p>Driver will respond to this command with: Respond_Gripper_data_pack</p> <p>Alternatively you can send empty Send_gripper_data_pack command.</p> <ul> <li>Command ID: 61 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_gripper_data_pack() </li> <li>Type of frame: standard </li> <li>Length: 0 byte </li> </ul> <p>Driver will respons to this command with: Respond_Gripper_data_pack</p>"},{"location":"apage7_can/#send_gripper_calibrate","title":"Send_gripper_calibrate","text":"<p>This command will start gripper calibration. It is an empty data frame.</p> <ul> <li>Command ID: 62 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_gripper_calibrate() </li> <li>Type of frame: standard </li> <li>Length: 0 byte </li> </ul> <p>Driver will not respond to this command!</p>"},{"location":"apage7_can/#send_pd_gains","title":"Send_PD_Gains","text":"<p>This command will set KP and KD gains for the PD impedance loop.</p> <ul> <li>Command ID: 16 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_PD_Gains() </li> <li>Type of frame: standard </li> <li>Length: 8 byte </li> </ul> Size (bytes) Variable Type 0 - 3 KP float 32 4 - 7 KD float 32 <p>Driver will not respond to this command!</p>"},{"location":"apage7_can/#send_current_gains","title":"Send_Current_Gains","text":"<p>This command will set Ki and Kp PI parameters for the PI current control loop.</p> <ul> <li>Command ID: 17 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_Current_Gains() </li> <li>Type of frame: standard </li> <li>Length: 8 byte </li> </ul> Size (bytes) Variable Type 0 - 3 Kp_iq float 32 4 - 7 Ki_iq float 32 <p>Driver will not respond to this command!</p>"},{"location":"apage7_can/#send_velocity_gains","title":"Send_Velocity_Gains","text":"<p>This command will set Ki and Kp PI parameters for the PI speed/velocity control loop.</p> <ul> <li>Command ID: 18 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_Velocity_Gains() </li> <li>Type of frame: standard </li> <li>Length: 8 byte </li> </ul> Size (bytes) Variable Type 0 - 3 Kpv float 32 4 - 7 Kiv float 32 <p>Driver will not respond to this command!</p>"},{"location":"apage7_can/#send_position_gains","title":"Send_Position_Gains","text":"<p>This command will set Kp P parameter for the P position control loop.</p> <ul> <li>Command ID: 19 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_Position_Gains() </li> <li>Type of frame: standard </li> <li>Length: 4 byte </li> </ul> Size (bytes) Variable Type 0 - 3 Kpp float 32 <p>Driver will not respond to this command!</p>"},{"location":"apage7_can/#send_limits","title":"Send_Limits","text":"<p>This command will set velocity/speed and current limits. This will limit max speed and current that can be reached during motor operation.</p> <ul> <li>Command ID: 20 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_Limits() </li> <li>Type of frame: standard </li> <li>Length: 8 byte </li> </ul> Size (bytes) Variable Type Details 0 - 3 Velocity limit float 32 unit is encoder ticks/s 3 - 7 Current limit float 32 unit is mA <p>Driver will not respond to this command!</p>"},{"location":"apage7_can/#send_kt","title":"Send_Kt","text":"<p>This command will set Kt of the motor driver.</p> <ul> <li>Command ID: 22 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_Kt() </li> <li>Type of frame: standard </li> <li>Length: 4 byte </li> </ul> Size (bytes) Variable Type 0 - 3 Kt float 32 <p>Driver will not respond to this command!</p>"},{"location":"apage7_can/#send_can_id","title":"Send_CAN_ID","text":"<p>This command will set a new CAN ID for your motor driver.  Note that ID you send is the new motor ID.</p> <ul> <li>Command ID: 11 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_CAN_ID() </li> <li>Type of frame: standard </li> <li>Length: 1 byte </li> </ul> Size (bytes) Variable Type 0 ID byte <p>Driver will not respond to this command!</p>"},{"location":"apage7_can/#send_estop","title":"Send_ESTOP","text":"<p>This command will stop the motor and set ESTOP error to 1.  It is an empty data frame.</p> <ul> <li>Command ID: 0 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_ESTOP() </li> <li>Type of frame: standard </li> <li>Length: 0 byte </li> </ul> <p>Driver will not respond to this command!</p>"},{"location":"apage7_can/#send_idle","title":"Send_Idle","text":"<p>This command will set the motor driver to idle state.  It is an empty data frame.</p> <ul> <li>Command ID: 12 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_Idle() </li> <li>Type of frame: standard </li> <li>Length: 0 byte </li> </ul> <p>Driver will not respond to this command!</p>"},{"location":"apage7_can/#send_save_config","title":"Send_Save_config","text":"<p>This command will save the current motor config to the EEPROM.  It is an empty data frame.</p> <ul> <li>Command ID: 13 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_Save_config() </li> <li>Type of frame: standard </li> <li>Length: 0 byte </li> </ul> <p>Driver will not respond to this command!</p>"},{"location":"apage7_can/#send_reset","title":"Send_Reset","text":"<p>This command will reset the MCU of the motor driver.  It is an empty data frame.</p> <ul> <li>Command ID: 14 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_Reset() </li> <li>Type of frame: standard </li> <li>Length: 0 byte </li> </ul> <p>Driver will not respond to this command!</p>"},{"location":"apage7_can/#send_clear_error","title":"Send_Clear_Error","text":"<p>This command will clear all active errors of the motor driver.  It is an empty data frame.</p> <ul> <li>Command ID: 1 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_Clear_Error() </li> <li>Type of frame: standard </li> <li>Length: 0 byte </li> </ul> <p>Driver will not respond to this command!</p>"},{"location":"apage7_can/#send_watchdog","title":"Send_Watchdog","text":"<p>This command will set Watchdog parameters like watchdog time and action.</p> <ul> <li>Command ID: 15 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_Watchdog() </li> <li>Type of frame: REMOTE </li> <li>Length: 5 byte </li> </ul> Size (bytes) Variable Type Details 0 - 3 watchdog_time_ms int 4 Action int *Not implemented"},{"location":"apage7_can/#send_heartbeat_setup","title":"Send_Heartbeat_Setup","text":"<p>This command will set heartbeat paramters of the motor driver.</p> <ul> <li>Command ID: 30 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_Heartbeat_Setup() </li> <li>Type of frame: REMOTE </li> <li>Length: 4 byte </li> </ul> Size (bytes) Variable Type 0 - 3 Heartbeat_rate_ms int"},{"location":"apage7_can/#send_cyclic_command","title":"Send_Cyclic_command","text":"<p>TODO</p>"},{"location":"apage7_can/#send_respond_temperature","title":"Send_Respond_Temperature","text":"<p>This command will request that motor driver responds with its current temperature. (Temperature of the thermistor).   Direction host -&gt; driver is remote frame and direction driver -&gt; host is standard data frame.</p> <ul> <li>Command ID: 23 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_Respond_Temperature() </li> <li>Type of frame: REMOTE </li> <li>Length: 0 byte </li> </ul> <p>Driver respond to this command with:</p> <ul> <li>Command ID: 23 </li> <li>Direction: BLDC driver -&gt; Host </li> <li>Python API reference: Send_Respond_Temperature() </li> <li>Type of frame: standard </li> <li>Length: 2 byte </li> </ul> Size (bytes) Variable (Spectral_BLDC Lib python attribute) Type Details 0 - 1 temperature 16 bit signed unit of degrees"},{"location":"apage7_can/#send_respond_voltage","title":"Send_Respond_Voltage","text":"<p>This command will request that motor driver responds with its current supply voltage.   Direction host -&gt; driver is remote frame and direction driver -&gt; host is standard data frame.</p> <ul> <li>Command ID: 24 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_Respond_Voltage() </li> <li>Type of frame: REMOTE </li> <li>Length: 0 byte </li> </ul> <p>Driver respond to this command with:</p> <ul> <li>Command ID: 24 </li> <li>Direction: BLDC driver -&gt; Host </li> <li>Python API reference: Send_Respond_Voltage() </li> <li>Type of frame: standard </li> <li>Length: 2 byte </li> </ul> Size (bytes) Variable (Spectral_BLDC Lib python attribute) Type Details 0 - 1 voltage 16 bit unsigned unit of mV"},{"location":"apage7_can/#send_respond_device_info","title":"Send_Respond_Device_Info","text":"<p>This command will request that motor driver responds with its version information saved in the EEPROM.    Direction host -&gt; driver is remote frame and direction driver -&gt; host is standard data frame.</p> <ul> <li>Command ID: 25 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_Respond_Device_Info() </li> <li>Type of frame: REMOTE </li> <li>Length: 0 byte </li> </ul> <p>Driver respond to this command with:</p> <ul> <li>Command ID: 25 </li> <li>Direction: BLDC driver -&gt; Host </li> <li>Python API reference: Send_Respond_Device_Info() </li> <li>Type of frame: standard </li> <li>Length: 7 byte </li> </ul> Size (bytes) Variable (Spectral_BLDC Lib python attribute) Type Details 0 HARDWARE_VERSION byte harware version of the driver 1 BATCH_DATE byte date when the batch was produced 2 SOFTWARE_VERSION byte version of the software on the driver 3 - 6 SERIAL_NUMBER 32 bit serial number of the driver"},{"location":"apage7_can/#send_respond_state_of_errors","title":"Send_Respond_State_of_Errors","text":"<p>This command will request that motor driver responds with state of all possible errors.   Direction host -&gt; driver is remote frame and direction driver -&gt; host is standard data frame.</p> <ul> <li>Command ID: 26 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_Respond_State_of_Errors() </li> <li>Type of frame: REMOTE </li> <li>Length: 0 byte </li> </ul> <p>Driver respond to this command with:</p> <ul> <li>Command ID: 26 </li> <li>Direction: BLDC driver -&gt; Host </li> <li>Python API reference: Send_Respond_State_of_Errors() </li> <li>Type of frame: standard </li> <li>Length: 2 byte </li> </ul> Size (bytes) Variable (Spectral_BLDC Lib python attribute) Type Details 0(bit 0) error bit (0/1) General error 0(bit 1) temperature_error bit (0/1) 0(bit 2) encoder_error bit (0/1) 0(bit 3) vbus_error bit (0/1) 0(bit 4) driver_error bit (0/1) 0(bit 5) velocity_error bit (0/1) 0(bit 6) current_error bit (0/1) 0(bit 7) estop_error bit (0/1) 1(bit 0) calibrated bit (0/1) 1(bit 0) activated bit (0/1) 1(bit 0) watchdog_error bit (0/1)"},{"location":"apage7_can/#send_respond_iq_data","title":"Send_Respond_Iq_data","text":"<p>This command will request that motor driver responds with current Iq current data.   Direction host -&gt; driver is remote frame and direction driver -&gt; host is standard data frame.</p> <ul> <li>Command ID: 27 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_Respond_Iq_data() </li> <li>Type of frame: REMOTE </li> <li>Length: 0 byte </li> </ul> <p>Driver respond to this command with:</p> <ul> <li>Command ID: 27 </li> <li>Direction: BLDC driver -&gt; Host </li> <li>Python API reference: Send_Respond_Iq_data() </li> <li>Type of frame: standard </li> <li>Length: 2 byte </li> </ul> Size (bytes) Variable (Spectral_BLDC Lib python attribute) Type Details 0 - 1 current signed 16bit unit is mA"},{"location":"apage7_can/#send_respond_encoder_data","title":"Send_Respond_Encoder_data","text":"<p>This command will request that motor driver responds with current encoder position and speed data.   Direction host -&gt; driver is remote frame and direction driver -&gt; host is standard data frame.</p> <ul> <li>Command ID: 28 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_Respond_Encoder_data() </li> <li>Type of frame: REMOTE </li> <li>Length: 0 byte </li> </ul> <p>Driver respond to this command with:</p> <ul> <li>Command ID: 28 </li> <li>Direction: BLDC driver -&gt; Host </li> <li>Python API reference: Send_Respond_Encoder_data() </li> <li>Type of frame: standard </li> <li>Length: 8 byte </li> </ul> Size (bytes) Variable (Spectral_BLDC Lib python attribute) Type Details 0 - 3 position signed 32bit unit is encoder ticks 4 - 7 velocity signed 32bit unit is encoder ticks/s"},{"location":"apage7_can/#send_respond_ping","title":"Send_Respond_Ping","text":"<p>This command will request that motor driver responds with its own ping.    Direction host -&gt; driver is remote frame and direction driver -&gt; host is standard data frame.</p> <ul> <li>Command ID: 10 </li> <li>Direction: Host -&gt; BLDC driver </li> <li>Python API reference: Send_Respond_Ping() </li> <li>Type of frame: REMOTE </li> <li>Length: 0 byte </li> </ul> <p>Driver respond to this command with:</p> <ul> <li>Command ID: 10 </li> <li>Direction: BLDC driver -&gt; Host</li> <li>Python API reference: Send_Respond_Ping() </li> <li>Type of frame: standard </li> <li>Length: 0 byte </li> </ul>"},{"location":"apage7_can/#more-about-can","title":"More about CAN","text":"<p>In CAN (Controller Area Network) communication, each byte of data within a CAN frame is transmitted as a sequence of bits. Each bit is transmitted serially, starting with the least significant bit (LSB) and ending with the most significant bit (MSB).</p> <p>So, if you send a byte with the value 0b10110000, it will be transmitted over the CAN bus as follows:</p> <ul> <li>Start Bit: The start bit is transmitted first (LSB).</li> <li>Data Bits: The data bits are transmitted serially, starting with the LSB (bit[0] = 0) and ending with the MSB (bit[7] = 1).</li> </ul> <p>Therefore, in the case of your byte 0b10110000, it will be transmitted as follows:</p> <p>Start Bit | Data Bits (LSB first) </p> <p>0       |     0  0  0  0  1  1  0  1 </p> <p>transmition of bytes is LSB byte first. So if we have data packet of 4 bytes; byte 3,2,1,0; byte 3 will be sent first and byte 0 last.</p> <p>Data is packed in arrays so that for 16 bit number, 8 MSB bits go to array index 0 and 8 LSB bits go to array index 1. When transmitting that data If you look here: https://en.wikipedia.org/wiki/CAN_bus LSB are sent first so array element with index 1 is transmitted first. So if we have number that is 32814 decimal: MSB byte[0] = 1000 0000 , LSB byte[1] = 0101 1010  It will be sent like this 0101 1010 0000 0001 </p> <p>Transmitting floats is following the IEEE 754 floating-point format.</p> <p>In IEEE 754 format, a single-precision floating-point number (float) is represented using 32 bits, with the following components:</p> <p>Sign bit: 1 bit, representing the sign of the number. Exponent bits: 8 bits, representing the exponent of the number. Fraction bits: 23 bits, representing the fractional part of the number. The function you provided interprets the input array of 4 bytes as a 32-bit integer and then uses a union to reinterpret those bits as a float. The bit manipulation performed by shifting the bytes and combining them respects the layout of IEEE 754 floating-point numbers, assuming that the byte order of the system is big-endian.</p> <p>Therefore, this function can be used to convert an array of 4 bytes representing a IEEE 754 float to its equivalent floating-point value.</p>"},{"location":"apage8_control_principles/","title":"Control principles","text":""},{"location":"apage8_control_principles/#todo","title":"TODO","text":""},{"location":"apage8_control_principles/#field-oriented-control-foc","title":"Field Oriented Control (FOC)","text":""},{"location":"apage8_control_principles/#pd-impedance-controller","title":"PD Impedance controller","text":""},{"location":"apage8_control_principles/#open-loop-controller","title":"Open loop controller","text":""},{"location":"apage8_control_principles/#impedance","title":"Impedance","text":"<p>Ima jako puno info u quads folder https://www.ias.informatik.tu-darmstadt.de/uploads/Team/TianyuRen/J1_forceContro_TianyuRen.pdf</p>"},{"location":"apage9_2_GUI/","title":"GUI interface","text":"<p>TODO</p>"},{"location":"apage9_3_tested_motors/","title":"Tested motors","text":"<p>Tip</p> <p>Look for the motors that have phase resistance ranging from 2 - 24 ohm.</p>"},{"location":"apage9_3_tested_motors/#tested-motors_1","title":"Tested motors","text":"Motor Name Specifications Link . BGM8108 Pole pairs: 21  Weight: 219 g   Phase to phase Resistance: 9.3 ohm   KV: Link . GBM5208 Pole pairs: 21  Weight: 219 g   Phase to phase Resistance: 9.3 ohm  KV: Link . 42BLS40-24-01 Pole pairs: 21  Weight: 219 g   Phase to phase Resistance: 9.3 ohm  KV: Link . 2804 Pole pairs: 21  Weight: 219 g   Phase to phase Resistance: 9.3 ohm  KV: Link . 2804 Pole pairs: 21  Weight: 219 g   Phase to phase Resistance: 9.3 ohm  KV: Link . GM5208 Pole pairs: 21  Weight: 219 g   Phase to phase Resistance: 9.3 ohm  KV: Link . GB4114 Pole pairs: 21  Weight: 219 g   Phase to phase Resistance: 9.3 ohm  KV: Link . GM8112 Pole pairs: 21  Weight: 219 g   Phase to phase Resistance: 9.3 ohm  KV: Link . GM7008H Pole pairs: 21  Weight: 219 g   Phase to phase Resistance: 9.3 ohm  KV: Link . GM6008H Pole pairs: 21  Weight: 219 g   Phase to phase Resistance: 9.3 ohm  KV: Link . GBM5010 Pole pairs: 21  Weight: 219 g   Phase to phase Resistance: 9.3 ohm  KV: Link . 2804 100KV Pole pairs: 21  Weight: 219 g   Phase to phase Resistance: 9.3 ohm  KV: Link"},{"location":"apage9_4_theory_corner/","title":"Theory corner","text":"<p>TODO</p> <p>Cool sites and articles: * https://robotics-explained.com/</p> <p>Describing impedance and admittance control in the context of a robot interacting with its environment can help clarify their differences and applications.</p>"},{"location":"apage9_4_theory_corner/#impedance-control","title":"Impedance Control","text":"<p>Concept: - Impedance control is like controlling how \"stiff\" or \"flexible\" the robot feels when it interacts with the environment. It defines how the robot resists motion in response to external forces. Impedance control regulates the force output of a system based on the position error.</p> <p>Analogy: - Imagine the robot's end effector is connected to the environment by a virtual spring-damper system. The robot adjusts the force it applies to mimic a specific stiffness, damping, and inertia.</p> <p>Implementation: - The robot measures its position, velocity, and possibly the force it applies. - The controller calculates the desired force or torque output based on the difference between the actual and desired position/velocity, considering virtual mass, damping, and stiffness. - The robot then applies this calculated force/torque to maintain the desired interaction characteristics.</p> <p>Example: - A robot arm is drilling into a surface. Impedance control ensures the robot maintains a steady drilling force despite variations in the surface hardness. If the surface becomes harder, the robot increases its force to maintain the drilling motion.</p> <p>Equation: $$F{\\text{control}}= \\frac{d^2x}{dt^2} + B \\frac{dx}{dt} + Kx \\$$</p>"},{"location":"apage9_4_theory_corner/#admittance-control","title":"Admittance Control","text":"<p>Concept: - Admittance control is like controlling how easily the robot moves in response to external forces. It defines how the robot adapts its position or velocity based on the forces applied by the environment. Admittance control regulates the position or velocity of a system based on the force error.</p> <p>Analogy: - Imagine the robot's end effector is like a balloon tethered to a point. The robot adjusts its position or velocity to move compliantly with the applied forces, mimicking a specific level of compliance and damping.</p> <p>Implementation: - The robot measures the external force applied to it and its own position and velocity. - The controller calculates the desired position or velocity based on the measured force, considering virtual compliance and damping. - The robot then adjusts its motion to match the desired position or velocity.</p> <p>Example: - A robot arm is holding a tray while a person places objects on it. Admittance control allows the robot to adjust its position smoothly to accommodate the added weight, ensuring the tray remains stable.</p> <p>Equation (for velocity admittance control): $$v_{\\text{desired}} = \\frac{F_{\\text{ext}} - Kx}{B} \\$$</p> <p>Equation (for position admittance control): $$x_{\\text{desired}} = \\frac{1}{K} F_{\\text{ext}} - \\frac{B}{K} v \\$$</p>"},{"location":"apage9_4_theory_corner/#summary","title":"Summary","text":"<p>Impedance Control: - Robot's Role: The robot reacts to position/velocity changes by applying forces to resist motion. - Control Focus: Force/torque output based on position/velocity error. - Interaction Feel: Defines how stiff or flexible the robot feels (resistance).</p> <p>Admittance Control: - Robot's Role: The robot adjusts its motion in response to external forces. - Control Focus: Position/velocity based on external force input. - Interaction Feel: Defines how easily the robot moves (compliance).</p>"},{"location":"apage9_4_theory_corner/#choosing-the-control-method","title":"Choosing the Control Method","text":"<ul> <li>Impedance Control: Suitable for tasks requiring precise force regulation and maintaining a specific motion despite external disturbances, such as machining or tasks where consistent force application is critical.</li> <li>Admittance Control: Suitable for tasks requiring adaptive and compliant motion, especially when interacting with unpredictable environments or humans, such as assisting or collaborating with humans in handling delicate objects.</li> </ul> <p>By understanding these control strategies in terms of how the robot interacts with its environment, one can better appreciate their applications and benefits in various robotic tasks.</p>"},{"location":"apage9_4_theory_corner/#compliance","title":"Compliance","text":"<p>Compliance, in the context of control systems and robotics, refers to the ability of a system to yield or deform in response to an applied force. It is the inverse of stiffness (or rigidity), which measures the resistance of a system to deformation. High compliance means the system is easily deformable or flexible, whereas low compliance (high stiffness) means the system is resistant to deformation.</p>"},{"location":"apage9_4_theory_corner/#key-concepts-of-compliance","title":"Key Concepts of Compliance","text":"<ul> <li> <p>Compliance ((C)): It is defined as the inverse of stiffness ((K)). Mathematically, compliance (C) can be expressed as:   [ C = \\frac{1}{K} ]   Where (K) is the stiffness of the system.</p> </li> <li> <p>Stiffness ((K)): It quantifies the resistance of a system to deformation. High stiffness means the system resists deformation strongly when a force is applied.</p> </li> </ul>"},{"location":"apage9_4_theory_corner/#compliance-in-control-systems","title":"Compliance in Control Systems","text":"<p>In control systems, particularly in robotics, compliance is crucial for safe and effective interaction with the environment, especially in tasks that involve human-robot interaction or handling delicate objects.</p>"},{"location":"apage9_4_theory_corner/#example-compliance-in-a-robotic-arm","title":"Example: Compliance in a Robotic Arm","text":"<p>Imagine a robotic arm equipped with compliance control. Here\u2019s how compliance plays a role:</p> <ol> <li>Interaction with the Environment:</li> <li>When the robotic arm encounters an obstacle, a compliant control system allows the arm to yield slightly, reducing the risk of damage to both the arm and the obstacle.</li> <li> <p>High compliance makes the arm flexible, allowing it to absorb and adapt to external forces smoothly.</p> </li> <li> <p>Human-Robot Interaction:</p> </li> <li>In collaborative tasks where a human and a robot work together, compliance ensures that the robot can adapt to the human\u2019s movements without exerting excessive force, enhancing safety and cooperation.</li> <li>If the human applies a force to the robot, a compliant robot will move or adjust its position in response, preventing injury or discomfort.</li> </ol>"},{"location":"apage9_4_theory_corner/#practical-implementation","title":"Practical Implementation","text":"<p>Compliance can be implemented in robotic systems through both passive and active means:</p> <ul> <li>Passive Compliance:</li> <li>Achieved using physical elements like springs, dampers, and flexible materials.</li> <li> <p>Example: A robotic gripper with soft, flexible fingers that conform to the shape of the object being held.</p> </li> <li> <p>Active Compliance:</p> </li> <li>Achieved using control algorithms that adjust the robot's motion or force output in real-time based on sensor feedback.</li> <li>Example: A robotic arm that uses force sensors to detect applied forces and adjusts its position or velocity accordingly, implementing virtual compliance through software.</li> </ul>"},{"location":"apage9_4_theory_corner/#compliance-in-control-equations","title":"Compliance in Control Equations","text":"<p>In control equations, compliance is often reflected in how the system responds to forces. For example, in admittance control, the system's compliance is an integral part of the control law:</p> <p>$$\\ x_{\\text{desired}} = C \\cdot F_{\\text{ext}} \\$$</p> <p>Where: - \\ x_{\\text{desired}} \\ is the desired position. - ( C ) is the compliance (inverse of stiffness). - ( F_{\\text{ext}} ) is the external force applied to the system.</p> <p>This equation shows that the desired position change is directly proportional to the applied force, with the proportionality factor being the compliance.</p>"},{"location":"apage9_4_theory_corner/#summary_1","title":"Summary","text":"<p>Compliance is a measure of how easily a system deforms in response to an applied force. In robotics and control systems, compliance is crucial for enabling smooth, adaptive, and safe interactions with the environment and humans. It is the inverse of stiffness and can be implemented both passively and actively. Understanding compliance helps in designing control systems that can effectively manage forces and movements, ensuring both precision and safety in robotic operations.</p>"},{"location":"apage9_5_troublestooting/","title":"Troubleshooting","text":""},{"location":"apage9_5_troublestooting/#led-indication","title":"LED indication","text":"Normal operation Calibration Error mode 3 short flashed and a pause  Flashing every 0.5 seconds  Solid LED, no flashing.  <p>If you have spectral firmware uploaded on your spectral BLDC LEDs will be in one of 3 states.</p> <ul> <li>Normal operation is when motor controller has no active errors and is calibrated</li> <li>Error mode is active if any error on the motor driver is active. List of possible errors:<ol> <li>Temperature error</li> <li>Drv error</li> <li>Encoder error</li> <li>Vbus error</li> <li>Velocity error</li> <li>Current error</li> <li>Not calibrated </li> <li>Received ESTOP</li> <li>Watchdog error</li> </ol> </li> <li>Calibration will flash when in calibration routine</li> </ul> <p>To clear errors you can call UART command #Clear or CAN command \"Send_Clear_Error\" Calling these commands will try to clear the error but if the error is still present it will activate again. </p> <p>For example your Vbus is 2V and you are getting Vbus error. You call #Clear but the error does not go away because the Vbus is still 2V.</p> <p>Another example is your Vbus is 2V and you are getting Vbus error. You now adjust your Vbus voltage to 24V. Vbus error is now gone but the driver is still in error state. Calling #Clear will place it in normal operation.</p>"},{"location":"apage9_5_troublestooting/#having-problems-with-your-setup-make-sure-to-check-these-common-problems","title":"Having problems with your setup? Make sure to check these common problems:","text":"<ol> <li>Magnet and encoder too far or too close</li> <li>Are you 100% sure your magnet is diametrically magnetised</li> <li>You have too big or too small velocity and current limits</li> <li>You hear crunching and whining sounds. Tune your PIDs especially current loop. Try to lower the current loop bandwidth during calibration</li> <li>You hear crunching and whining sounds. Your current limit might be too high, lower it.</li> <li>Are you motor phases in short or open circuit?</li> <li>Do you have a current limit set on your power supply?</li> <li>Is your CAN bus correctly terminated?</li> <li>Is your encoder magnet aligned in the center of the pcb and does not wobble?</li> <li>Is your motor compatible with the motor driver?</li> <li>Motor is wobbling left and right during calibration? One of your phases is disconnected</li> </ol>"},{"location":"apage9_5_troublestooting/#magnet-and-encoder-problems","title":"Magnet and encoder problems","text":"<ul> <li>Recommended distance between encoder and the magnet is 1mm.</li> <li>Even if calibration reports that magnet status is ok; it can still be too close or too far from the encoder. You need to make sure in your mechanical design that distance between the magnet and the encoder is respected.</li> <li>Magnet too close or touching the sensor of the spectral BLDC can brick and even destroy the mcu.</li> <li>Magnet too far from the encoder will report invalid data from the encoder. </li> </ul>"},{"location":"apage9_5_troublestooting/#low-quality-motors","title":"Low quality motors","text":"<ul> <li>Windings are visually bad</li> <li>Bemf of the motor looks really bad and uneven</li> <li>Resistance between phases differs a lot</li> </ul>"},{"location":"apage9_5_troublestooting/#motor-temperature","title":"Motor temperature","text":"<ul> <li>If termistor is not placed in motor windings your motor can overheat.</li> <li>Overheating can reduce performance and destroy your motor windings and BLDC controller</li> </ul>"},{"location":"apage9_5_troublestooting/#driver-temperature","title":"Driver temperature","text":"<p>If driver gets over some temperature it will automatically shut down. This is hardware feture of the hardware chip we use and cant be modified in software. </p>"},{"location":"apage9_5_troublestooting/#calibration-issuses","title":"Calibration issuses","text":"<p>Check calibration page for these issues.</p>"},{"location":"apage9_5_troublestooting/#can-bus-issues","title":"CAN bus issues","text":"<ul> <li>Make sure you use correct baud rate; default is 1Mbit</li> <li>First and last node on the CAN bus should have termination resistors of 120ohm. To test that remove your device from any power and use multimeter to mesure resistance between CANH and CANL anywhere on the bus; it should be around 60 ohms.</li> <li>Use twisted pair wires.</li> </ul>"},{"location":"apage9_5_troublestooting/#uart-issues","title":"UART issues","text":"<ul> <li>Make sure you have same baud rate on spectral BLDC and host device. Default for spectral BLDC is 256000</li> </ul>"},{"location":"Guides/Arduino%20guide/","title":"Arduino guide","text":""},{"location":"Guides/Arduino%20guide/#uart-arduino-guide","title":"UART Arduino guide","text":""},{"location":"Guides/Arduino%20guide/#can-arduino-guide","title":"CAN arduino guide","text":""},{"location":"Guides/Arduino%20guide/#library-references","title":"Library references","text":""},{"location":"Guides/Bilateral%20teleoperation%20guide/","title":"Bilateral teleoperation guide","text":""},{"location":"Guides/Bilateral%20teleoperation%20guide/#what-is-bilateral-teleoperation","title":"What is bilateral teleoperation?","text":"<p>Bilateral teleoperation is a concept that Involves two-way communication where both the operator and the remote device send and receive feedback. The operator controls the device remotely and receives sensory feedback (such as force) from the device to adjust their actions.</p> <p>The two grippers are virtually coupled to each other, allowing either to act as the master (the haptic interface) or the slave (the manipulator) in the system. We are not using a force sensor at the grippers but are relying on proprioception.</p> <p></p> <p>Watch these example videos to get a \"feel\" of the concept:</p> <ul> <li>Gripper bilateral </li> <li>2DOF arm bilateral</li> </ul> <p>What is this used for?</p> <p>These kind of setup is perfect for: Teleoperation, Imitation learning, Virtual Environments...</p>"},{"location":"Guides/Bilateral%20teleoperation%20guide/#the-algorithm","title":"The algorithm","text":"<p>The magic of this setup is done with these 2 simple formulas.</p> <p>We got them from amazing Ben Katz paper, creator of mini cheetah quad: Link to the paper</p> <p>\ud835\udf0f1,\ud835\udc56 = \ud835\udc3e\ud835\udc5d(\ud835\udf032,\ud835\udc56 \u2212 \ud835\udf031, \ud835\udc56) + \ud835\udc3e\ud835\udc51( \u02d9\ud835\udf032,\ud835\udc56 \u2212 \u02d9\ud835\udf031,\ud835\udc56) \u2212 \ud835\udc3e( \u02d9\ud835\udf031,\ud835\udc56)</p> <p>\ud835\udf0f2,\ud835\udc56 = \ud835\udc3e\ud835\udc5d(\ud835\udf031,\ud835\udc56 \u2212 \ud835\udf032, \ud835\udc56) + \ud835\udc3e\ud835\udc51( \u02d9\ud835\udf031,\ud835\udc56 \u2212 \u02d9\ud835\udf032,\ud835\udc56) \u2212 \ud835\udc3e( \u02d9\ud835\udf032,\ud835\udc56)</p> <p>Learn more!</p> <p>You can read more on how it works in our blog post!</p>"},{"location":"Guides/Bilateral%20teleoperation%20guide/#what-you-will-need","title":"What you will need","text":"<p>We recommend these items to create a simple test jig:</p> <ul> <li>2 x spectral micro BLDC - used for 2 wheels </li> <li>Wires to connect everything up: CAN wires, Power wires</li> <li>2 x BLDC motors or SSG48 grippers</li> <li>1 x CAN adapter</li> <li>1 x 24V power supply</li> <li>A Laptop or raspberry pi</li> <li>UART adapter</li> </ul>"},{"location":"Guides/Bilateral%20teleoperation%20guide/#setup","title":"Setup","text":"<p>Here we are showing you the setup for any 2 motors, for example we are using 2 x ssg48 grippers that are connected in exactly the same setup.</p> <p></p> <p>You will need to follow the diagram above to wire everything up.</p> <ul> <li>First you need to calibrate your Spectral BLDC drivers with the motors you are using. </li> <li>After that change the CAN ids of one of the drivers to CAN 1. You can do it by using UART commands: #CANID 1 and after that #Save</li> <li>Now connect CAN adapters CAN bus to one of the drivers and then from that driver connect to the second driver. Make sure that last driver in chain has its CAN termination resistor in \"ON\" state</li> <li>Connect the power to both drivers. You can daisy chain it or use 2 seperate wires.</li> </ul>"},{"location":"Guides/Bilateral%20teleoperation%20guide/#the-code","title":"The code","text":"<p>This code will run on your PC and it will communicate with the drivers from the CAN adapter.</p> <p>Advanced example</p> <p>More advanced code that allows communication over UDP can be found here: Link </p> Spectral_mobile_robot_xbox.py<pre><code>import Spectral_BLDC as Spectral\nimport SourceRoboticsToolbox as SourceRoboticsToolbox\nimport time\nimport numpy as np\nfrom math import pi, sin, cos\nfrom spatialmath import *\nfrom typing import Union, Any, List, Optional, cast\n\nNeeded_joint_pos = np.array([100,100]) # If using gripper you will need to adjust this\nJoint_reduction_ratio = [1, 1] # Reduction ratio we have on our joints\n\nCommunication1 = Spectral.CanCommunication(bustype='slcan', channel='COM123', bitrate=1000000)\n\nMotor: list[Union[Spectral.SpectralCAN,Spectral.SpectralCAN]] = []\nMotor.append(Spectral.SpectralCAN(node_id=0, communication=Communication1))\nMotor.append(Spectral.SpectralCAN(node_id=1, communication=Communication1))\n\n\nJoint: list[Union[SourceRoboticsToolbox.Joint,SourceRoboticsToolbox.Joint]] = []\nJoint.append(SourceRoboticsToolbox.Joint(encoder_resolution = 14, master_position=Needed_joint_pos[0], gear_ratio = Joint_reduction_ratio[0], offset = 0, dir = 0))\nJoint.append(SourceRoboticsToolbox.Joint(encoder_resolution = 14, master_position=Needed_joint_pos[1], gear_ratio = Joint_reduction_ratio[1], offset = 0, dir = 0))\n\ntimeout_setting = 0.001\n\ninitial = 0\ninitial_setup = [0,0]\n\n# Initialize position values\nposition_values =  np.array([0.0,0.0])\nMotor_values = np.array([0,0])\n\nspeed_values = np.array([0,0])\n\nposition_send = np.array([0,0])\nspeed_send = np.array([0,0])\nT0 = 0\nT1 = 0\n\nreceived_ids = [0,0] \nKp = 650\nKd = 0.00550 #  0.0060\nKk = 0.0003 #0.0003\n\n\nwhile(1):\n    t1 = time.perf_counter()\n    Motor[0].Send_data_pack_1(Position = None,Speed = None, Current = int(T0))\n    Motor[1].Send_data_pack_1(Position = None,Speed = None, Current = int(T1))\n\n    for i in range(1, 3):  # Loop 9-1=8 to check for received data\n        message, UnpackedMessageID = Communication1.receive_can_messages(timeout=timeout_setting)\n        #print(f\"unpack{i} is: {UnpackedMessageID}\")\n\n        # Check if UnpackedMessageID is not None \n        if UnpackedMessageID is not None:\n\n            # Update received id index; meaning that we received response from that CAN ID\n            received_ids[UnpackedMessageID[0]] = 1\n            Motor[UnpackedMessageID[0]].UnpackData(message,UnpackedMessageID)\n            #print(f\"Motor {UnpackedMessageID[0]}, position is: {Motor[UnpackedMessageID[0]].position}\")\n            unwrapped_position_raw = Joint[UnpackedMessageID[0]].unwrap_position(Motor[UnpackedMessageID[0]].position)\n            Motor_values[UnpackedMessageID[0]] = Motor[UnpackedMessageID[0]].position\n            position_values[UnpackedMessageID[0]] =  Joint[UnpackedMessageID[0]].get_joint_position(Motor[UnpackedMessageID[0]].position)\n\n            if initial_setup[UnpackedMessageID[0]] == 0:\n                initial_setup[UnpackedMessageID[0]] = 1\n                Joint[UnpackedMessageID[0]].determine_sector(Motor[UnpackedMessageID[0]].position)\n\n    # The magic\n    T0 = Kp*( position_values[1] -  position_values[0]) + Kd*(Motor[1].speed - Motor[0].speed) - Kk*(Motor[0].speed)\n    T1 = Kp*( position_values[0] -  position_values[1]) + Kd*(Motor[0].speed - Motor[1].speed) - Kk*(Motor[1].speed)\n    # There are no delays here, we send as fast as possible!\n</code></pre>"},{"location":"Guides/Mobile%20robot%20guide/","title":"Mobile robot guide","text":""},{"location":"Guides/Mobile%20robot%20guide/#intro","title":"Intro","text":"<p>This guide is a really simple example on how you can control mobile robot based on spectral micro BLDC drives using xbox controller! </p> <p>By following this guide you will be able to make something like this: Link!</p> <p>Python API</p> <p>This guide leverages Spectral BLDC python API</p> <p>What you will need to create a simple mobile robot is:</p> <ul> <li>2 x spectral micro BLDC - used for 2 wheels </li> <li>Wires to connect everything up: CAN wires, Power wires</li> <li>2 x BLDC motors</li> <li>1 x CAN adapter</li> <li>1 x Drill battery adapter: Example - This is great way to power your BLDC motors with cheap and affortable batteries</li> <li>A Laptop or raspberry pi</li> <li>Xbox controller</li> </ul> <p>Building the robot</p> <p>In this guide we only recommend you the hardware you can use to build the robot you designed. We do not offer already made designs you can build!</p>"},{"location":"Guides/Mobile%20robot%20guide/#setup","title":"Setup","text":"<p>The setup will be the same for any kind of mobile robot. You will need to follow the  diagram above to wire everything up.</p> <ul> <li>First you need to calibrate your Spectral BLDC drivers with the motors you are using. </li> <li>After that change the CAN ids of one of the drivers to CAN 1. You can do it by using UART commands: #CANID 1 and after that #Save</li> <li>Now connect CAN adapters CAN bus to one of the drivers and then from that driver connect to the second driver. Make sure that last driver in chain has its CAN termination resistor in \"ON\" state</li> <li>Connect the power to both drivers. You can daisy chain it or use 2 seperate wires.</li> <li>You will also need to connect your xbox controller to the PC/laptop via Bluetooth.</li> </ul> <p>The code below is really simple example that drives the robot using the left joystick of the controller.</p> Spectral_mobile_robot_xbox.py<pre><code>from inputs import get_gamepad\nimport math\nimport threading\nimport time\nimport Spectral_BLDC as Spectral\n\n\nCommunication1 = Spectral.CanCommunication(bustype='slcan', channel='COM3', bitrate=1000000)\nMotor = []\n\n# We are using 2 motors with IDs 0 and 1\nMotor.append(Spectral.SpectralCAN(node_id=0, communication=Communication1))\nMotor.append(Spectral.SpectralCAN(node_id=1, communication=Communication1))\n\n\ntimeout_setting = 0.00005\n\nMAX_JOY_VAL = math.pow(2, 15)\nDEADBAND_THRESHOLD = 0.1\n\n# Read xbox controller and output left joystick x and y positions\ndef read_left_joystick():\n    left_joystick_x = 0\n    left_joystick_y = 0\n\n    def monitor_left_joystick():\n        nonlocal left_joystick_x, left_joystick_y\n        while True:\n            events = get_gamepad()\n            for event in events:\n                if event.code == 'ABS_Y':\n                    left_joystick_y = event.state / MAX_JOY_VAL  # normalize between -1 and 1\n                elif event.code == 'ABS_X':\n                    left_joystick_x = event.state / MAX_JOY_VAL  # normalize between -1 and 1\n\n\n                  # Apply deadband\n                if abs(left_joystick_x) &lt; DEADBAND_THRESHOLD:\n                    left_joystick_x = 0\n                if abs(left_joystick_y) &lt; DEADBAND_THRESHOLD:\n                    left_joystick_y = 0\n\n    monitor_thread = threading.Thread(target=monitor_left_joystick)\n    monitor_thread.daemon = True\n    monitor_thread.start()\n\n    while True:\n        yield left_joystick_x, left_joystick_y\n\n# Robot control \ndef control_robot():\n    for x, y in read_left_joystick():\n        # Assuming the robot has two wheels and speed can be controlled independently\n        left_wheel_speed = y + x\n        right_wheel_speed = y - x\n\n        # Limit the speed between -1 and 1\n        left_wheel_speed = max(min(left_wheel_speed, 1), -1)\n        right_wheel_speed = max(min(right_wheel_speed, 1), -1)\n\n        # Use the calculated speeds to control the robot's wheels        \n        print(\"Left Wheel Speed:\", left_wheel_speed)\n        print(\"Right Wheel Speed:\", right_wheel_speed)\n\n\n        # Send data to all motors\n        Motor[0].Send_data_pack_1(None,int(left_wheel_speed * 1000000),0)\n        Motor[1].Send_data_pack_1(None,int(right_wheel_speed * -1000000),0)\n\n        for i in range(1, 4):  # Loop 9-1=8 to check for received data\n            message, UnpackedMessageID = Communication1.receive_can_messages(timeout=timeout_setting)\n            print(f\"unpack{i} is: {UnpackedMessageID}\")\n\n            # Check if UnpackedMessageID is not None \n            if UnpackedMessageID is not None:\n\n                Motor[UnpackedMessageID[0]].UnpackData(message,UnpackedMessageID)\n                print(f\"Motor {UnpackedMessageID[0]}, speed is: {Motor[UnpackedMessageID[0]].speed}\")\n\n\n        time.sleep(0.05)\n\nif __name__ == '__main__':\n    control_robot()\n</code></pre>"},{"location":"Guides/Python%20guide/","title":"Python guide","text":""},{"location":"Guides/Python%20guide/#how-to-connect","title":"How to connect","text":""},{"location":"Guides/Python%20guide/#python-package","title":"Python package","text":"<p>naredbe sve</p>"},{"location":"Guides/Python%20guide/#examples","title":"Examples","text":"Get_encoder_data.py<pre><code>import Spectral_BLDC as Spectral\nimport time\n\n# Init comms channel \nCommunication1 = Spectral.CanCommunication(bustype='slcan', channel='COM41', bitrate=1000000)\n# Init motor object\nMotor1 = Spectral.SpectralCAN(node_id=0, communication=Communication1)\n\nwhile True:\n\n    # Send this msg to the motor controller, it will respond with position and speed data\n    Motor1.Send_Respond_Encoder_data()\n\n    # Get CAN msg, timeout tells us to continue if there is no msg after in this case 0.2 s\n    message, UnpackedMessageID = Communication1.receive_can_messages(timeout=0.2) \n\n    # If there was a msg unpack it\n    if message is not None:\n        print(f\"Message is: {message}\")\n        print(f\"Node ID is : {UnpackedMessageID.node_id}\")\n        print(f\"Message ID is: {UnpackedMessageID.command_id}\")\n        print(f\"Error bit is: {UnpackedMessageID.error_bit}\")\n        print(f\"Message length is: {message.dlc}\")\n        print(f\"Is is remote frame: {message.is_remote_frame}\")\n        print(f\"Timestamp is: {message.timestamp}\")\n\n        # Here we unpack the data from the packet\n        Motor1.UnpackData(message,UnpackedMessageID)\n        # We are interested in position and speed data that was requested by calling Send_Respond_Encoder_data\n        print(f\"Motor position is: {Motor1.position}\")\n        print(f\"Motor speed is: {Motor1.speed}\")\n\n\n    else:\n        print(\"No message after timeout period!\")\n    print(\"\")\n    time.sleep(1 )\n</code></pre>"},{"location":"Guides/Quadruped%20guide/","title":"Quadruped robot guide","text":""},{"location":"Guides/Quadruped%20guide/#intro","title":"Intro","text":"<p>In this quide we wil show you how you can control a leg of any quadruped robot using Spectral micro BLDC drivers. If you can control one of them you can control all the rest!</p> <p>After you finish this guide you will be able to do something like this: Link </p> <p>Python API and toolbox</p> <p>This guide leverages Spectral BLDC python API and Source robotics toolbox</p> <p></p> <p>Building the LEG</p> <p>In this guide we only recommend you the hardware you can use to build the robot you designed. We do not offer already made designs you can build!</p> <p>This guide will cover:</p> <ul> <li>How to define the robot leg kinematic chain</li> <li>How to execute simple trajectories with the leg</li> </ul> <p>What you will need:</p> <ul> <li>2 x spectral micro BLDC </li> <li>Wires to connect everything up: CAN wires, Power wires</li> <li>2 x BLDC motors</li> <li>1 x CAN adapter</li> <li>1 x 24V power supply</li> <li>A Laptop or raspberry pi</li> </ul> <p></p> <p>The setup will be the same for any kind of quadruped leg. You will need to follow the diagram above to wire everything up.</p> <ul> <li>First you need to calibrate your Spectral BLDC drivers with the motors you are using. </li> <li>After that change the CAN ids of one of the drivers to CAN 1. You can do it by using UART commands: #CANID 1 and after that #Save</li> <li>Now connect CAN adapters CAN bus to one of the drivers and then from that driver connect to the second driver. Make sure that last driver in chain has its CAN termination resistor in \"ON\" state</li> <li>Connect the power to both drivers. (Use daisy chain)</li> </ul>"},{"location":"Guides/Quadruped%20guide/#leg-kinematics","title":"Leg kinematics","text":"<p>First you will need to assign coordinate frames to your leg model. We already did it but if you want to learn more on how and why check this Link</p> <p>Now we will need to find DH (Denavit-Hartenberg) table values. You can learn more on how and why we did it Here!</p> <p>value l1 is 0.112 meters and value l2 is 0.1 meters. The frame 2 is the end / foot of our leg.</p>"},{"location":"Guides/Quadruped%20guide/#testing-calibrating-the-leg","title":"Testing / Calibrating the leg","text":"<p>Before running the main code lets check if the comms are working and get initial position values of our robot leg. This code will try to get data from the 2 motors of our robot leg. We are most interested in positon data of those 2 motors. Position the leg like shown in this image. Run the leg_calib code and write down position values of each motor. </p> <p></p> leg_calib.py<pre><code>import Spectral_BLDC as Spectral\nimport time\n\n\nCommunication1 = Spectral.CanCommunication(bustype='slcan', channel='COM6', bitrate=1000000)\nMotor = []\n\nMotor.append(Spectral.SpectralCAN(node_id=0, communication=Communication1))\nMotor.append(Spectral.SpectralCAN(node_id=1, communication=Communication1)) \n\n\ntimeout_setting = 0.00005\n\n\nwhile True:\n\n    Motor[0].Send_Respond_Encoder_data()\n    Motor[1].Send_Respond_Encoder_data()\n\n    for i in range(1, 7):  # Loop 9-1=8 to check for received data\n        message, UnpackedMessageID = Communication1.receive_can_messages(timeout=timeout_setting)\n        print(f\"unpack {i} is: {UnpackedMessageID}\")\n\n        # Check if UnpackedMessageID is not None \n        if UnpackedMessageID is not None:\n            #print(Motor)\n            # Update received id index; meaning that we received response from that CAN ID\n            Motor[UnpackedMessageID[0]].UnpackData(message,UnpackedMessageID)\n            print(f\"Motor {UnpackedMessageID [0]}, speed is: {Motor[UnpackedMessageID[0]].speed}, current is {Motor[UnpackedMessageID[0]].current },pos is {Motor[UnpackedMessageID[0]].position}\")\n            \"\"\"\n            print(f\"Motor {UnpackedMessageID[0]}, speed is: {Motor[UnpackedMessageID[0]].speed}\")\n            print(f\"Error is: {Motor[UnpackedMessageID[0]].error}\")\n            print(f\"Temperature rror is: {Motor[UnpackedMessageID[0]].temperature_error}\")\n            print(f\"Encoder error is: {Motor[UnpackedMessageID[0]].encoder_error}\")\n            print(f\"Vbus error is: {Motor[UnpackedMessageID[0]].vbus_error}\")\n            print(f\"Driver error is: {Motor[UnpackedMessageID[0]].driver_error}\")\n            print(f\"Velocity error is: {Motor[UnpackedMessageID[0]].velocity_error}\")\n            print(f\"Current error is: {Motor[UnpackedMessageID[0]].current_error}\")\n            print(f\"Estop error is: {Motor[UnpackedMessageID[0]].estop_error}\")\n            print(f\"Watchdog error is: {Motor[UnpackedMessageID[0]].watchdog_error}\")\n            print(f\"Calibrated is: {Motor[UnpackedMessageID[0]].calibrated}\")\n            print(f\"Activated is: {Motor[UnpackedMessageID[0]].activated}\")\n            \"\"\"\n\n\n    time.sleep(0.5)\n</code></pre>"},{"location":"Guides/Quadruped%20guide/#follow-a-specific-trajectory","title":"Follow a specific trajectory","text":"<p>Joint level control involves directly controlling the angles or positions of the robot's individual joints. Each joint is treated as an independent actuator, and the control system sends commands to each joint to achieve the desired angles. </p> <p>For this example we will not use joint level control but a different method called Task/Cartesian Level Control.  Task or cartesian level control focuses on controlling the position and orientation of the robot's end-effector in a Cartesian coordinate system (X, Y, Z coordinates and orientations). In our robot leg case we dont have Z axes (or orientation) and our end-effector is foot (end of our robot leg).</p> <p>In this example we will follow a circle trajectory i X,Y plane. We defined that trajectory with our function generate_circle_coords and with parameters: </p> <ul> <li>center - Tuple representing the center coordinates (x, y) in meters</li> <li>radius - Radius of the circle in meters</li> <li>speed - Speed of the end-effector in meters per second</li> <li>time_var - Elapsed time in seconds</li> </ul> <p></p> <p>How precise you follow the trajectory depends on the speed you set. With low speeds you can track the circle perflectly. With larger speeds the system cant keep up and overshoots. This is due multiple reaseons like:</p> <ul> <li>Inertia and Momentum: At higher speeds, the inertia and momentum of the robot leg increase, making it harder to change directions quickly and accurately.</li> <li>Centrifugal and Coriolis Forces</li> <li>Trajectory Planning and Execution - at higher speeds our trajectory has less points to create a full circle. This is due a fixed rate we send data to our motors eg. every 20ms. </li> <li>Feedforward Control: Lack of proper feedforward control can lead to errors in trajectory tracking, as the controller might not anticipate the required accelerations and decelerations.</li> </ul> <p>You can see that from the example with speed set to 1 and 3.</p>"},{"location":"Guides/Quadruped%20guide/#example-code","title":"Example code","text":"<p>This code will make your robot leg draw the above circles. It might look complicated but it is not. Once you understand how this example works you can use it as a base for building more complicated projects. </p> 2DOF_leg_demo.py<pre><code>import Spectral_BLDC as Spectral\nimport SourceRoboticsToolbox as SourceRoboticsToolbox\nimport time\nimport numpy as np\n# We are using v1.1.0\nfrom roboticstoolbox import DHRobot, RevoluteDH, ERobot, ELink, ETS\nfrom math import pi, sin, cos\nfrom spatialmath import *\nfrom oclock import Timer, loop, interactiveloop\nimport math\nfrom typing import Union, Any, List, Optional, cast\nINTERVAL_S = 0.02\n\n\nNeeded_joint_pos = np.array([14000,2430]) # These are the positions we got from calib code\nJoint_reduction_ratio = [1, 0.90476190] # Reduction ratio we have on our joints\n\n# Setup your CAN coms. Change the channel to match your CAN adapter\nCommunication1 = Spectral.CanCommunication(bustype='slcan', channel='COM6', bitrate=1000000)\n\n# Define our motors\nMotor: list[Union[Spectral.SpectralCAN,Spectral.SpectralCAN]] = []\nMotor.append(Spectral.SpectralCAN(node_id=0, communication=Communication1))\nMotor.append(Spectral.SpectralCAN(node_id=1, communication=Communication1))\n\n# Define the joints\nJoint: list[Union[SourceRoboticsToolbox.Joint,SourceRoboticsToolbox.Joint]] = []\nJoint.append(SourceRoboticsToolbox.Joint(encoder_resolution = 14, master_position=Needed_joint_pos[0], gear_ratio = Joint_reduction_ratio[0], offset = -np.pi/2, dir = 0))\nJoint.append(SourceRoboticsToolbox.Joint(encoder_resolution = 14, master_position=Needed_joint_pos[1], gear_ratio = Joint_reduction_ratio[1], offset = 0, dir = 0))\n\ntimeout_setting = 0.001\n\ninitial = 0\ninitial_setup = [0,0]\n\ntesting = 5\n\n# Initialize position values\nposition_values =  np.array([0.0,0.0])\nMotor_values = np.array([0,0])\nreceived_ids = [0,0]\n\n\n# robot length values (metres)\nl = [0.112, 0.1]\n\nalpha_DH = [0,0]\n\n# Create robot model using DH params\nL1 = RevoluteDH(a=l[0],d = 0,alpha=alpha_DH[0])\nL2 = RevoluteDH(a=l[1],d = 0,alpha=alpha_DH[1])\nrobot = DHRobot([L1,L2], name=\"Two link\")\n\nprev_pos = np.array([0,0])\nspeed_var = np.array([0,0])\n\ndef generate_circle_coords(center, radius, speed, time):\n  \"\"\"\n  Generates x,y coordinates for a circle at a given time, considering constant speed.\n\n  Args:\n      center: Tuple representing the center coordinates (x, y) in meters.\n      radius: Radius of the circle in meters.\n      speed: Speed of the end-effector in meters per second.\n      time: Elapsed time in seconds.\n\n  Returns:\n      Tuple containing the x and y coordinates in meters.\n  \"\"\"\n\n  # Calculate angular displacement based on speed and time\n  angular_displacement = speed * time\n\n  # Use parametric equations for a circle to generate coordinates\n  x = center[0] + radius * math.cos(angular_displacement)\n  y = center[1] + radius * math.sin(angular_displacement)\n\n  return (x, y)\n\ndef save_xy_data(filename, xy_data):\n  \"\"\"\n  Saves a list of x,y coordinates to a text file.\n\n  Args:\n      filename (str): The name of the text file to save the data to.\n      xy_data (list): A list of tuples containing x and y coordinates.\n  \"\"\"\n\n  with open(filename, 'a') as file:\n    for x, y in xy_data:\n      file.write(f\"{x},{y}\\n\")\n\n# Example usage with update loop (adjust update_interval for your needs)\ncenter = (-0.04, -0.17)\nradius = 0.03\nspeed = 0.8\ntime_var = 0\n\n# We are using oclock module to generate stable interval defined with INTERVAL_S\ntimer = Timer(interval=INTERVAL_S, warnings=False, precise=True)\nwhile timer.elapsed_time &lt; 1100000:\n\n    t1 = time.perf_counter()\n    #Motor[0].Send_Respond_Encoder_data()\n    #Motor[1].Send_Respond_Encoder_data()\n    Motor[0].Send_data_pack_1(Position = Needed_joint_pos[0],Speed = speed_var[0], Current = 0)\n    Motor[1].Send_data_pack_1(Position = Needed_joint_pos[1],Speed = speed_var[1], Current = 0)\n\n    # Handles data we get from the motors\n    for i in range(1, 3):  # Loop 9-1=8 to check for received data\n        message, UnpackedMessageID = Communication1.receive_can_messages(timeout=timeout_setting)\n        #print(f\"unpack{i} is: {UnpackedMessageID}\")\n\n        # Check if UnpackedMessageID is not None \n        if UnpackedMessageID is not None:\n\n            # Update received id index; meaning that we received response from that CAN ID\n            received_ids[UnpackedMessageID[0]] = 1\n            Motor[UnpackedMessageID[0]].UnpackData(message,UnpackedMessageID)\n            #print(f\"Motor {UnpackedMessageID[0]}, position is: {Motor[UnpackedMessageID[0]].position}\")\n            unwrapped_position_raw = Joint[UnpackedMessageID[0]].unwrap_position(Motor[UnpackedMessageID[0]].position)\n            Motor_values[UnpackedMessageID[0]] = Motor[UnpackedMessageID[0]].position\n            position_values[UnpackedMessageID[0]] =  Joint[UnpackedMessageID[0]].get_joint_position(Motor[UnpackedMessageID[0]].position)\n\n            if initial_setup[UnpackedMessageID[0]] == 0:\n                initial_setup[UnpackedMessageID[0]] = 1\n                Joint[UnpackedMessageID[0]].determine_sector(Motor[UnpackedMessageID[0]].position)\n\n    # Generate desired x,y coordinates with respect to time_var\n    x, y = generate_circle_coords(center, radius, speed, time_var)\n\n    # Create a matrix with those x,y coordinates\n    T2 = SE3(x, y, 0)\n    # Perform inverse kinematics (get joint data from x,y data)\n    q1 = robot.ik_LM(T2, q0 = [-0.8,-1],mask = [1,1,0,0,0,0])\n    Needed_joint_pos[0] = Joint[0].get_encoder_position(q1[0][0])\n    Needed_joint_pos[1] = Joint[1].get_encoder_position(q1[0][1])  \n    speed_var[0] = ((Needed_joint_pos[0] - prev_pos[0]) / INTERVAL_S)\n    speed_var[1] = ((Needed_joint_pos[1] - prev_pos[1]) / INTERVAL_S)\n    print(speed_var)\n    prev_pos[0] = Needed_joint_pos[0]\n    prev_pos[1] = Needed_joint_pos[1]\n    # Process or visualize the generated coordinates (x, y)\n    #print(f\"Time: {time_var:.2f}s, Coordinates: ({x:.4f}, {y:.4f})\")\n\n    # Update time\n    time_var += INTERVAL_S\n\n    t2 = time.perf_counter()\n    #print(f\"total time is {t2-t1}\")\n\n    T = robot.fkine(position_values)\n    xy = T.t\n    #print(f\"{xy[0]},{xy[1]}\")\n    xy_data = [(xy[0], xy[1])]  # Assuming xy is a single pair of coordinates\n    # Save data to a txt file\n    save_xy_data('my_data.txt', xy_data)\n    #time.sleep(0.05)\n</code></pre>"},{"location":"Guides/Quadruped%20guide/#plot-data","title":"Plot data","text":"<p>Script that will plot the data of your leg:</p> plot_leg_data.py<pre><code>import matplotlib.pyplot as plt\n\ndef plot_data(filename):\n  \"\"\"\n  Plots data from a text file in the format:\n  x1, y1\n  x2, y2\n  ...\n\n  Args:\n      filename (str): The name of the text file containing the data.\n  \"\"\"\n\n  try:\n    with open(filename, 'r') as file:\n      data = file.readlines()\n\n    x_data = []\n    y_data = []\n    for line in data:\n      # Split the line based on comma (\",\")\n      values = line.strip().split(',')\n\n      # Check if there are exactly two values per line\n      if len(values) != 2:\n        raise ValueError(f\"Invalid line format in file '{filename}': {line}\")\n\n      try:\n        x = float(values[0])\n        y = float(values[1])\n      except ValueError:\n        raise ValueError(f\"Invalid data type in file '{filename}': {line}\")\n\n      x_data.append(x)\n      y_data.append(y)\n\n    # Ensure equal x and y scales\n    plt.axis('equal')\n\n    # Create the plot\n    plt.plot(x_data, y_data)\n\n    # Customize the plot (optional)\n    plt.xlabel('X-Position')\n    plt.ylabel('Y-Position')\n    plt.title('Data Plot from ' + filename)\n\n    plt.grid(True)\n    plt.show()\n\n  except FileNotFoundError:\n    print(f\"Error: File '{filename}' not found.\")\n  except (ValueError, TypeError) as e:\n    print(f\"Error: {e}\")\n\n# Example usage\nfilename = 'C:\\\\Users\\\\xx\\\\Desktop\\\\test_code\\\\env\\\\Robot_leg\\\\data_2.txt'  # Replace with your actual filename\nplot_data(filename)\n</code></pre>"},{"location":"Guides/SIMPLEFOC%20guide/","title":"Simple FOC guide","text":"<p>Tested with Simple FOC@^2.3.2 release</p> <p>Main firmware that runs on Spectral micro is Spectral firmware.</p> <p>SimpleFOC is alternative to Spectral Firmware.  The library is intended both for:</p> <ul> <li>Beginners searching for a simple and user-friendly way to learn how to control BLDC and Stepper motors</li> <li>Advanced users ready to dig deeper into the FOC algorithm and optimize the code for their particular application/hardware.</li> </ul> <p>More info about simple FOC:</p> <ul> <li>Forum</li> <li>DOCS</li> <li>Discord</li> </ul> <p>SimpleFOC forum and discord is best place to look for help when developing with SimpleFOC library</p>"},{"location":"Guides/SIMPLEFOC%20guide/#how-to-install","title":"How to install","text":"<p>Follow this guide</p> <p>Your platformio.ini should look like this:</p> main.cpp<pre><code>[env:genericSTM32F103CB]\nplatform = ststm32\nboard = genericSTM32F103CB\nframework = arduino\nupload_protocol = stlink\nbuild_flags = \ndebug_tool = stlink\nmonitor_speed = 115200\nlib_deps = \n    askuric/Simple FOC@^2.3.2\nlib_archive = false\n</code></pre>"},{"location":"Guides/SIMPLEFOC%20guide/#simplefoc-guides","title":"SimpleFOC guides","text":"<p>If you want to develop more advanced applications with SimpleFOC you can follow these tutorials:</p> <ul> <li>Getting started</li> <li>Writting the code</li> <li>SimpleFOC Driver and Support Library</li> </ul>"},{"location":"Guides/SIMPLEFOC%20guide/#basic-example","title":"Basic example","text":"<p>This example will spin the motor in open loop and enable serial monitor. Use this code as a base for more advanced code you will develop with SimpleFOC. In the github folder we also offer full FOC example!</p> main.cpp<pre><code>#include \"Arduino.h\"\n#include \"SimpleFOC.h\"\n\n// Driver PWM pins\n#define PWM_CH1 PA_2\n#define PWM_CH2 PA_1 \n#define PWM_CH3 PA_0 \n\n// Encoder pins\n#define MOSI PB_5\n#define MISO PB_4\n#define CLK PB_3\n#define CSN PA_15\n\n#define SENSE1 PA_4 // Inline current sense\n#define SENSE2  PA_3 // Inline current sense\n\n#define TX_COM PB_6\n#define RX_COM PB_7\n\n// Current sense resistors\n#define SENSE_RESISTOR 0.025f\n#define CURRENT_AMP_GAIN 20\n\n// Serial pins\n#define Serial Serialx\nHardwareSerial Serialx(RX_COM, TX_COM); // PA3, PA2 RX,TX\n\n// BLDC motor &amp; driver instance\n// BLDCMotor motor = BLDCMotor(pole pair number, phase resistance (optional) );\nBLDCMotor motor = BLDCMotor(11);\n//  BLDCDriver3PWM( pin_pwmA, pin_pwmB, pin_pwmC )\nBLDCDriver3PWM driver = BLDCDriver3PWM(PWM_CH1, PWM_CH2, PWM_CH3);\n\n//target variable\nfloat target_velocity = 0.1;\n\nvoid Init_pins();\n\nvoid setup() {  \n\n  // Init driver enable pins and LED\n  Init_pins();\n\n  // pwm frequency to be used [Hz]\n  driver.pwm_frequency = 20000;\n  // power supply voltage [V]\n  driver.voltage_power_supply = 24;\n  // Max DC voltage allowed - default voltage_power_supply\n  driver.voltage_limit = 5;\n  // driver init\n  driver.init();\n    // link the motor and the driver\n  motor.linkDriver(&amp;driver);\n  motor.controller = MotionControlType::velocity_openloop;\n\n  // init motor hardware\n  motor.init();\n    // use monitoring with the BLDCMotor\n  Serial.begin(115200);\n  Serial.println(\"Motor ready!\");\n  _delay(1000);\n  // monitoring port\n  motor.useMonitoring(Serial);\n\n}\n\nvoid loop() {\n  // open loop velocity movement\n  // using motor.voltage_limit and motor.velocity_limit\n  motor.move(target_velocity);\n  // monitoring function outputting motor variables to the serial terminal \n  motor.monitor();\n\n}\n\nvoid Init_pins(){\n  pinMode(PA_9, OUTPUT);\n    pinMode(PA_8, OUTPUT);\n    pinMode(PA_10, OUTPUT);\n    pinMode(PB_15, OUTPUT);\n    pinMode(PB_14, OUTPUT);\n    pinMode(PB_13, OUTPUT);\n\n  digitalWrite(PA_9,HIGH);\n  digitalWrite(PA_8,HIGH);\n  digitalWrite(PA_10,HIGH);\n  digitalWrite(PB_14, HIGH);\n  digitalWrite(PB_15, HIGH);\n  digitalWrite(PB_13, HIGH);\n}\n</code></pre>"},{"location":"Guides/UART%20communication%20guide/","title":"Serial terminal guide","text":""}]}